// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: messages.proto

package messages

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// *
// Mapping between Skywallet wire identifier (uint) and a protobuf message
type MessageType int32

const (
	MessageType_MessageType_Initialize MessageType = 0
	MessageType_MessageType_Ping       MessageType = 1
	MessageType_MessageType_Success    MessageType = 2
	MessageType_MessageType_Failure    MessageType = 3
	MessageType_MessageType_ChangePin  MessageType = 4
	MessageType_MessageType_WipeDevice MessageType = 5
	// Bootloader
	MessageType_MessageType_FirmwareErase                MessageType = 6
	MessageType_MessageType_FirmwareUpload               MessageType = 7
	MessageType_MessageType_GetRawEntropy                MessageType = 9
	MessageType_MessageType_Entropy                      MessageType = 10
	MessageType_MessageType_LoadDevice                   MessageType = 13
	MessageType_MessageType_ResetDevice                  MessageType = 14
	MessageType_MessageType_Features                     MessageType = 17
	MessageType_MessageType_PinMatrixRequest             MessageType = 18
	MessageType_MessageType_PinMatrixAck                 MessageType = 19
	MessageType_MessageType_Cancel                       MessageType = 20
	MessageType_MessageType_ApplySettings                MessageType = 25
	MessageType_MessageType_ButtonRequest                MessageType = 26
	MessageType_MessageType_ButtonAck                    MessageType = 27
	MessageType_MessageType_BackupDevice                 MessageType = 34
	MessageType_MessageType_EntropyRequest               MessageType = 35
	MessageType_MessageType_EntropyAck                   MessageType = 36
	MessageType_MessageType_PassphraseRequest            MessageType = 41
	MessageType_MessageType_PassphraseAck                MessageType = 42
	MessageType_MessageType_RecoveryDevice               MessageType = 45
	MessageType_MessageType_WordRequest                  MessageType = 46
	MessageType_MessageType_WordAck                      MessageType = 47
	MessageType_MessageType_GetFeatures                  MessageType = 55
	MessageType_MessageType_PassphraseStateRequest       MessageType = 77
	MessageType_MessageType_PassphraseStateAck           MessageType = 78
	MessageType_MessageType_SetMnemonic                  MessageType = 113
	MessageType_MessageType_SkycoinAddress               MessageType = 114
	MessageType_MessageType_SkycoinCheckMessageSignature MessageType = 115
	MessageType_MessageType_SkycoinSignMessage           MessageType = 116
	MessageType_MessageType_ResponseSkycoinAddress       MessageType = 117
	MessageType_MessageType_ResponseSkycoinSignMessage   MessageType = 118
	MessageType_MessageType_GenerateMnemonic             MessageType = 119
	MessageType_MessageType_TransactionSign              MessageType = 122
	MessageType_MessageType_ResponseTransactionSign      MessageType = 123
	MessageType_MessageType_GetMixedEntropy              MessageType = 124
	MessageType_MessageType_SignTx                       MessageType = 125
	MessageType_MessageType_TxRequest                    MessageType = 126
	MessageType_MessageType_TxAck                        MessageType = 127
	MessageType_MessageType_BitcoinTxAck                 MessageType = 128
	MessageType_MessageType_BitcoinAddress               MessageType = 129
	MessageType_MessageType_EthereumAddress              MessageType = 130
	MessageType_MessageType_EtherumTxAck                 MessageType = 131
)

var MessageType_name = map[int32]string{
	0:   "MessageType_Initialize",
	1:   "MessageType_Ping",
	2:   "MessageType_Success",
	3:   "MessageType_Failure",
	4:   "MessageType_ChangePin",
	5:   "MessageType_WipeDevice",
	6:   "MessageType_FirmwareErase",
	7:   "MessageType_FirmwareUpload",
	9:   "MessageType_GetRawEntropy",
	10:  "MessageType_Entropy",
	13:  "MessageType_LoadDevice",
	14:  "MessageType_ResetDevice",
	17:  "MessageType_Features",
	18:  "MessageType_PinMatrixRequest",
	19:  "MessageType_PinMatrixAck",
	20:  "MessageType_Cancel",
	25:  "MessageType_ApplySettings",
	26:  "MessageType_ButtonRequest",
	27:  "MessageType_ButtonAck",
	34:  "MessageType_BackupDevice",
	35:  "MessageType_EntropyRequest",
	36:  "MessageType_EntropyAck",
	41:  "MessageType_PassphraseRequest",
	42:  "MessageType_PassphraseAck",
	45:  "MessageType_RecoveryDevice",
	46:  "MessageType_WordRequest",
	47:  "MessageType_WordAck",
	55:  "MessageType_GetFeatures",
	77:  "MessageType_PassphraseStateRequest",
	78:  "MessageType_PassphraseStateAck",
	113: "MessageType_SetMnemonic",
	114: "MessageType_SkycoinAddress",
	115: "MessageType_SkycoinCheckMessageSignature",
	116: "MessageType_SkycoinSignMessage",
	117: "MessageType_ResponseSkycoinAddress",
	118: "MessageType_ResponseSkycoinSignMessage",
	119: "MessageType_GenerateMnemonic",
	122: "MessageType_TransactionSign",
	123: "MessageType_ResponseTransactionSign",
	124: "MessageType_GetMixedEntropy",
	125: "MessageType_SignTx",
	126: "MessageType_TxRequest",
	127: "MessageType_TxAck",
	128: "MessageType_BitcoinTxAck",
	129: "MessageType_BitcoinAddress",
	130: "MessageType_EthereumAddress",
	131: "MessageType_EtherumTxAck",
}
var MessageType_value = map[string]int32{
	"MessageType_Initialize":                   0,
	"MessageType_Ping":                         1,
	"MessageType_Success":                      2,
	"MessageType_Failure":                      3,
	"MessageType_ChangePin":                    4,
	"MessageType_WipeDevice":                   5,
	"MessageType_FirmwareErase":                6,
	"MessageType_FirmwareUpload":               7,
	"MessageType_GetRawEntropy":                9,
	"MessageType_Entropy":                      10,
	"MessageType_LoadDevice":                   13,
	"MessageType_ResetDevice":                  14,
	"MessageType_Features":                     17,
	"MessageType_PinMatrixRequest":             18,
	"MessageType_PinMatrixAck":                 19,
	"MessageType_Cancel":                       20,
	"MessageType_ApplySettings":                25,
	"MessageType_ButtonRequest":                26,
	"MessageType_ButtonAck":                    27,
	"MessageType_BackupDevice":                 34,
	"MessageType_EntropyRequest":               35,
	"MessageType_EntropyAck":                   36,
	"MessageType_PassphraseRequest":            41,
	"MessageType_PassphraseAck":                42,
	"MessageType_RecoveryDevice":               45,
	"MessageType_WordRequest":                  46,
	"MessageType_WordAck":                      47,
	"MessageType_GetFeatures":                  55,
	"MessageType_PassphraseStateRequest":       77,
	"MessageType_PassphraseStateAck":           78,
	"MessageType_SetMnemonic":                  113,
	"MessageType_SkycoinAddress":               114,
	"MessageType_SkycoinCheckMessageSignature": 115,
	"MessageType_SkycoinSignMessage":           116,
	"MessageType_ResponseSkycoinAddress":       117,
	"MessageType_ResponseSkycoinSignMessage":   118,
	"MessageType_GenerateMnemonic":             119,
	"MessageType_TransactionSign":              122,
	"MessageType_ResponseTransactionSign":      123,
	"MessageType_GetMixedEntropy":              124,
	"MessageType_SignTx":                       125,
	"MessageType_TxRequest":                    126,
	"MessageType_TxAck":                        127,
	"MessageType_BitcoinTxAck":                 128,
	"MessageType_BitcoinAddress":               129,
	"MessageType_EthereumAddress":              130,
	"MessageType_EtherumTxAck":                 131,
}

func (x MessageType) Enum() *MessageType {
	p := new(MessageType)
	*p = x
	return p
}
func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}
func (x *MessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MessageType_value, data, "MessageType")
	if err != nil {
		return err
	}
	*x = MessageType(value)
	return nil
}
func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{0}
}

// *
// Type of information required by transaction signing process
type TxRequest_RequestType int32

const (
	TxRequest_TXINPUT     TxRequest_RequestType = 0
	TxRequest_TXOUTPUT    TxRequest_RequestType = 1
	TxRequest_TXMETA      TxRequest_RequestType = 2
	TxRequest_TXFINISHED  TxRequest_RequestType = 3
	TxRequest_TXEXTRADATA TxRequest_RequestType = 4
)

var TxRequest_RequestType_name = map[int32]string{
	0: "TXINPUT",
	1: "TXOUTPUT",
	2: "TXMETA",
	3: "TXFINISHED",
	4: "TXEXTRADATA",
}
var TxRequest_RequestType_value = map[string]int32{
	"TXINPUT":     0,
	"TXOUTPUT":    1,
	"TXMETA":      2,
	"TXFINISHED":  3,
	"TXEXTRADATA": 4,
}

func (x TxRequest_RequestType) Enum() *TxRequest_RequestType {
	p := new(TxRequest_RequestType)
	*p = x
	return p
}
func (x TxRequest_RequestType) String() string {
	return proto.EnumName(TxRequest_RequestType_name, int32(x))
}
func (x *TxRequest_RequestType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TxRequest_RequestType_value, data, "TxRequest_RequestType")
	if err != nil {
		return err
	}
	*x = TxRequest_RequestType(value)
	return nil
}
func (TxRequest_RequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{42, 0}
}

// *
// Request: Reset device to default state and ask for device details
// @next Features
type Initialize struct {
	State                []byte   `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Initialize) Reset()         { *m = Initialize{} }
func (m *Initialize) String() string { return proto.CompactTextString(m) }
func (*Initialize) ProtoMessage()    {}
func (*Initialize) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{0}
}
func (m *Initialize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Initialize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Initialize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Initialize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Initialize.Merge(dst, src)
}
func (m *Initialize) XXX_Size() int {
	return m.Size()
}
func (m *Initialize) XXX_DiscardUnknown() {
	xxx_messageInfo_Initialize.DiscardUnknown(m)
}

var xxx_messageInfo_Initialize proto.InternalMessageInfo

func (m *Initialize) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

// *
// Request: Ask for device details (no device reset)
// @next Features
type GetFeatures struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetFeatures) Reset()         { *m = GetFeatures{} }
func (m *GetFeatures) String() string { return proto.CompactTextString(m) }
func (*GetFeatures) ProtoMessage()    {}
func (*GetFeatures) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{1}
}
func (m *GetFeatures) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFeatures) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFeatures.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetFeatures) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFeatures.Merge(dst, src)
}
func (m *GetFeatures) XXX_Size() int {
	return m.Size()
}
func (m *GetFeatures) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFeatures.DiscardUnknown(m)
}

var xxx_messageInfo_GetFeatures proto.InternalMessageInfo

// *
// Response: Reports various information about the device
// @prev Initialize
// @prev GetFeatures
type Features struct {
	Vendor               *string  `protobuf:"bytes,1,opt,name=vendor" json:"vendor,omitempty"`
	MajorVersion         *uint32  `protobuf:"varint,2,opt,name=major_version,json=majorVersion" json:"major_version,omitempty"`
	MinorVersion         *uint32  `protobuf:"varint,3,opt,name=minor_version,json=minorVersion" json:"minor_version,omitempty"`
	PatchVersion         *uint32  `protobuf:"varint,4,opt,name=patch_version,json=patchVersion" json:"patch_version,omitempty"`
	BootloaderMode       *bool    `protobuf:"varint,5,opt,name=bootloader_mode,json=bootloaderMode" json:"bootloader_mode,omitempty"`
	DeviceId             *string  `protobuf:"bytes,6,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	PinProtection        *bool    `protobuf:"varint,7,opt,name=pin_protection,json=pinProtection" json:"pin_protection,omitempty"`
	PassphraseProtection *bool    `protobuf:"varint,8,opt,name=passphrase_protection,json=passphraseProtection" json:"passphrase_protection,omitempty"`
	Language             *string  `protobuf:"bytes,9,opt,name=language" json:"language,omitempty"`
	Label                *string  `protobuf:"bytes,10,opt,name=label" json:"label,omitempty"`
	Initialized          *bool    `protobuf:"varint,12,opt,name=initialized" json:"initialized,omitempty"`
	BootloaderHash       []byte   `protobuf:"bytes,14,opt,name=bootloader_hash,json=bootloaderHash" json:"bootloader_hash,omitempty"`
	PinCached            *bool    `protobuf:"varint,16,opt,name=pin_cached,json=pinCached" json:"pin_cached,omitempty"`
	PassphraseCached     *bool    `protobuf:"varint,17,opt,name=passphrase_cached,json=passphraseCached" json:"passphrase_cached,omitempty"`
	FirmwarePresent      *bool    `protobuf:"varint,18,opt,name=firmware_present,json=firmwarePresent" json:"firmware_present,omitempty"`
	NeedsBackup          *bool    `protobuf:"varint,19,opt,name=needs_backup,json=needsBackup" json:"needs_backup,omitempty"`
	Model                *string  `protobuf:"bytes,21,opt,name=model" json:"model,omitempty"`
	FwMajor              *uint32  `protobuf:"varint,22,opt,name=fw_major,json=fwMajor" json:"fw_major,omitempty"`
	FwMinor              *uint32  `protobuf:"varint,23,opt,name=fw_minor,json=fwMinor" json:"fw_minor,omitempty"`
	FwPatch              *uint32  `protobuf:"varint,24,opt,name=fw_patch,json=fwPatch" json:"fw_patch,omitempty"`
	FwVersionHead        *string  `protobuf:"bytes,25,opt,name=fw_version_head,json=fwVersionHead" json:"fw_version_head,omitempty"`
	FwVendor             *string  `protobuf:"bytes,26,opt,name=fw_vendor,json=fwVendor" json:"fw_vendor,omitempty"`
	FwVendorKeys         []byte   `protobuf:"bytes,27,opt,name=fw_vendor_keys,json=fwVendorKeys" json:"fw_vendor_keys,omitempty"`
	UnfinishedBackup     *bool    `protobuf:"varint,28,opt,name=unfinished_backup,json=unfinishedBackup" json:"unfinished_backup,omitempty"`
	FirmwareFeatures     *uint32  `protobuf:"varint,29,opt,name=firmware_features,json=firmwareFeatures" json:"firmware_features,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Features) Reset()         { *m = Features{} }
func (m *Features) String() string { return proto.CompactTextString(m) }
func (*Features) ProtoMessage()    {}
func (*Features) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{2}
}
func (m *Features) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Features) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Features.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Features) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Features.Merge(dst, src)
}
func (m *Features) XXX_Size() int {
	return m.Size()
}
func (m *Features) XXX_DiscardUnknown() {
	xxx_messageInfo_Features.DiscardUnknown(m)
}

var xxx_messageInfo_Features proto.InternalMessageInfo

func (m *Features) GetVendor() string {
	if m != nil && m.Vendor != nil {
		return *m.Vendor
	}
	return ""
}

func (m *Features) GetMajorVersion() uint32 {
	if m != nil && m.MajorVersion != nil {
		return *m.MajorVersion
	}
	return 0
}

func (m *Features) GetMinorVersion() uint32 {
	if m != nil && m.MinorVersion != nil {
		return *m.MinorVersion
	}
	return 0
}

func (m *Features) GetPatchVersion() uint32 {
	if m != nil && m.PatchVersion != nil {
		return *m.PatchVersion
	}
	return 0
}

func (m *Features) GetBootloaderMode() bool {
	if m != nil && m.BootloaderMode != nil {
		return *m.BootloaderMode
	}
	return false
}

func (m *Features) GetDeviceId() string {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return ""
}

func (m *Features) GetPinProtection() bool {
	if m != nil && m.PinProtection != nil {
		return *m.PinProtection
	}
	return false
}

func (m *Features) GetPassphraseProtection() bool {
	if m != nil && m.PassphraseProtection != nil {
		return *m.PassphraseProtection
	}
	return false
}

func (m *Features) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return ""
}

func (m *Features) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *Features) GetInitialized() bool {
	if m != nil && m.Initialized != nil {
		return *m.Initialized
	}
	return false
}

func (m *Features) GetBootloaderHash() []byte {
	if m != nil {
		return m.BootloaderHash
	}
	return nil
}

func (m *Features) GetPinCached() bool {
	if m != nil && m.PinCached != nil {
		return *m.PinCached
	}
	return false
}

func (m *Features) GetPassphraseCached() bool {
	if m != nil && m.PassphraseCached != nil {
		return *m.PassphraseCached
	}
	return false
}

func (m *Features) GetFirmwarePresent() bool {
	if m != nil && m.FirmwarePresent != nil {
		return *m.FirmwarePresent
	}
	return false
}

func (m *Features) GetNeedsBackup() bool {
	if m != nil && m.NeedsBackup != nil {
		return *m.NeedsBackup
	}
	return false
}

func (m *Features) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return ""
}

func (m *Features) GetFwMajor() uint32 {
	if m != nil && m.FwMajor != nil {
		return *m.FwMajor
	}
	return 0
}

func (m *Features) GetFwMinor() uint32 {
	if m != nil && m.FwMinor != nil {
		return *m.FwMinor
	}
	return 0
}

func (m *Features) GetFwPatch() uint32 {
	if m != nil && m.FwPatch != nil {
		return *m.FwPatch
	}
	return 0
}

func (m *Features) GetFwVersionHead() string {
	if m != nil && m.FwVersionHead != nil {
		return *m.FwVersionHead
	}
	return ""
}

func (m *Features) GetFwVendor() string {
	if m != nil && m.FwVendor != nil {
		return *m.FwVendor
	}
	return ""
}

func (m *Features) GetFwVendorKeys() []byte {
	if m != nil {
		return m.FwVendorKeys
	}
	return nil
}

func (m *Features) GetUnfinishedBackup() bool {
	if m != nil && m.UnfinishedBackup != nil {
		return *m.UnfinishedBackup
	}
	return false
}

func (m *Features) GetFirmwareFeatures() uint32 {
	if m != nil && m.FirmwareFeatures != nil {
		return *m.FirmwareFeatures
	}
	return 0
}

// *
// Request: change language and/or label of the device
// @start
// @next Success
// @next Failure
type ApplySettings struct {
	Language             *string  `protobuf:"bytes,1,opt,name=language" json:"language,omitempty"`
	Label                *string  `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	UsePassphrase        *bool    `protobuf:"varint,3,opt,name=use_passphrase,json=usePassphrase" json:"use_passphrase,omitempty"`
	Homescreen           []byte   `protobuf:"bytes,4,opt,name=homescreen" json:"homescreen,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApplySettings) Reset()         { *m = ApplySettings{} }
func (m *ApplySettings) String() string { return proto.CompactTextString(m) }
func (*ApplySettings) ProtoMessage()    {}
func (*ApplySettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{3}
}
func (m *ApplySettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplySettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplySettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ApplySettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplySettings.Merge(dst, src)
}
func (m *ApplySettings) XXX_Size() int {
	return m.Size()
}
func (m *ApplySettings) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplySettings.DiscardUnknown(m)
}

var xxx_messageInfo_ApplySettings proto.InternalMessageInfo

func (m *ApplySettings) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return ""
}

func (m *ApplySettings) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *ApplySettings) GetUsePassphrase() bool {
	if m != nil && m.UsePassphrase != nil {
		return *m.UsePassphrase
	}
	return false
}

func (m *ApplySettings) GetHomescreen() []byte {
	if m != nil {
		return m.Homescreen
	}
	return nil
}

// *
// Request: Ask the device to generate a mnemonic and configure itself with it
// @next Success
type GenerateMnemonic struct {
	PassphraseProtection *bool    `protobuf:"varint,1,opt,name=passphrase_protection,json=passphraseProtection" json:"passphrase_protection,omitempty"`
	WordCount            *uint32  `protobuf:"varint,2,opt,name=word_count,json=wordCount" json:"word_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateMnemonic) Reset()         { *m = GenerateMnemonic{} }
func (m *GenerateMnemonic) String() string { return proto.CompactTextString(m) }
func (*GenerateMnemonic) ProtoMessage()    {}
func (*GenerateMnemonic) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{4}
}
func (m *GenerateMnemonic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateMnemonic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateMnemonic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GenerateMnemonic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateMnemonic.Merge(dst, src)
}
func (m *GenerateMnemonic) XXX_Size() int {
	return m.Size()
}
func (m *GenerateMnemonic) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateMnemonic.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateMnemonic proto.InternalMessageInfo

func (m *GenerateMnemonic) GetPassphraseProtection() bool {
	if m != nil && m.PassphraseProtection != nil {
		return *m.PassphraseProtection
	}
	return false
}

func (m *GenerateMnemonic) GetWordCount() uint32 {
	if m != nil && m.WordCount != nil {
		return *m.WordCount
	}
	return 0
}

// *
// Request: Send a mnemonic to the device
// @next Success
type SetMnemonic struct {
	Mnemonic             *string  `protobuf:"bytes,1,req,name=mnemonic" json:"mnemonic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetMnemonic) Reset()         { *m = SetMnemonic{} }
func (m *SetMnemonic) String() string { return proto.CompactTextString(m) }
func (*SetMnemonic) ProtoMessage()    {}
func (*SetMnemonic) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{5}
}
func (m *SetMnemonic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetMnemonic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetMnemonic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetMnemonic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetMnemonic.Merge(dst, src)
}
func (m *SetMnemonic) XXX_Size() int {
	return m.Size()
}
func (m *SetMnemonic) XXX_DiscardUnknown() {
	xxx_messageInfo_SetMnemonic.DiscardUnknown(m)
}

var xxx_messageInfo_SetMnemonic proto.InternalMessageInfo

func (m *SetMnemonic) GetMnemonic() string {
	if m != nil && m.Mnemonic != nil {
		return *m.Mnemonic
	}
	return ""
}

// *
// Request: Starts workflow for setting/changing/removing the PIN
// @next ButtonRequest
// @next PinMatrixRequest
type ChangePin struct {
	Remove               *bool    `protobuf:"varint,1,opt,name=remove" json:"remove,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangePin) Reset()         { *m = ChangePin{} }
func (m *ChangePin) String() string { return proto.CompactTextString(m) }
func (*ChangePin) ProtoMessage()    {}
func (*ChangePin) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{6}
}
func (m *ChangePin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChangePin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePin.Merge(dst, src)
}
func (m *ChangePin) XXX_Size() int {
	return m.Size()
}
func (m *ChangePin) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePin.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePin proto.InternalMessageInfo

func (m *ChangePin) GetRemove() bool {
	if m != nil && m.Remove != nil {
		return *m.Remove
	}
	return false
}

// *
// Request: Generate a Skycoin or a Bitcoin address from a seed, device sends back the address in a Success message
// @next Failure
// @next ResponseSkycoinAddress
type SkycoinAddress struct {
	AddressN             *uint32  `protobuf:"varint,1,req,name=address_n,json=addressN" json:"address_n,omitempty"`
	StartIndex           *uint32  `protobuf:"varint,2,opt,name=start_index,json=startIndex" json:"start_index,omitempty"`
	ConfirmAddress       *bool    `protobuf:"varint,3,opt,name=confirm_address,json=confirmAddress" json:"confirm_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SkycoinAddress) Reset()         { *m = SkycoinAddress{} }
func (m *SkycoinAddress) String() string { return proto.CompactTextString(m) }
func (*SkycoinAddress) ProtoMessage()    {}
func (*SkycoinAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{7}
}
func (m *SkycoinAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkycoinAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkycoinAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SkycoinAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkycoinAddress.Merge(dst, src)
}
func (m *SkycoinAddress) XXX_Size() int {
	return m.Size()
}
func (m *SkycoinAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_SkycoinAddress.DiscardUnknown(m)
}

var xxx_messageInfo_SkycoinAddress proto.InternalMessageInfo

func (m *SkycoinAddress) GetAddressN() uint32 {
	if m != nil && m.AddressN != nil {
		return *m.AddressN
	}
	return 0
}

func (m *SkycoinAddress) GetStartIndex() uint32 {
	if m != nil && m.StartIndex != nil {
		return *m.StartIndex
	}
	return 0
}

func (m *SkycoinAddress) GetConfirmAddress() bool {
	if m != nil && m.ConfirmAddress != nil {
		return *m.ConfirmAddress
	}
	return false
}

// *
// Response: Return the generated skycoin address
// @prev SkycoinAddress
type ResponseSkycoinAddress struct {
	Addresses            []string `protobuf:"bytes,1,rep,name=addresses" json:"addresses,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseSkycoinAddress) Reset()         { *m = ResponseSkycoinAddress{} }
func (m *ResponseSkycoinAddress) String() string { return proto.CompactTextString(m) }
func (*ResponseSkycoinAddress) ProtoMessage()    {}
func (*ResponseSkycoinAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{8}
}
func (m *ResponseSkycoinAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseSkycoinAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseSkycoinAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ResponseSkycoinAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseSkycoinAddress.Merge(dst, src)
}
func (m *ResponseSkycoinAddress) XXX_Size() int {
	return m.Size()
}
func (m *ResponseSkycoinAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseSkycoinAddress.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseSkycoinAddress proto.InternalMessageInfo

func (m *ResponseSkycoinAddress) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

// *
// Response: Return the signatures necessary for the transaction
// @prev TransactionSign
type ResponseTransactionSign struct {
	Signatures           []string `protobuf:"bytes,1,rep,name=signatures" json:"signatures,omitempty"`
	Padding              *bool    `protobuf:"varint,2,req,name=padding" json:"padding,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseTransactionSign) Reset()         { *m = ResponseTransactionSign{} }
func (m *ResponseTransactionSign) String() string { return proto.CompactTextString(m) }
func (*ResponseTransactionSign) ProtoMessage()    {}
func (*ResponseTransactionSign) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{9}
}
func (m *ResponseTransactionSign) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseTransactionSign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseTransactionSign.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ResponseTransactionSign) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseTransactionSign.Merge(dst, src)
}
func (m *ResponseTransactionSign) XXX_Size() int {
	return m.Size()
}
func (m *ResponseTransactionSign) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseTransactionSign.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseTransactionSign proto.InternalMessageInfo

func (m *ResponseTransactionSign) GetSignatures() []string {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *ResponseTransactionSign) GetPadding() bool {
	if m != nil && m.Padding != nil {
		return *m.Padding
	}
	return false
}

// *
// Request: Check a message signature matches the given address.
// @next Success
type SkycoinCheckMessageSignature struct {
	Address              *string  `protobuf:"bytes,1,req,name=address" json:"address,omitempty"`
	Message              *string  `protobuf:"bytes,2,req,name=message" json:"message,omitempty"`
	Signature            *string  `protobuf:"bytes,3,req,name=signature" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SkycoinCheckMessageSignature) Reset()         { *m = SkycoinCheckMessageSignature{} }
func (m *SkycoinCheckMessageSignature) String() string { return proto.CompactTextString(m) }
func (*SkycoinCheckMessageSignature) ProtoMessage()    {}
func (*SkycoinCheckMessageSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{10}
}
func (m *SkycoinCheckMessageSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkycoinCheckMessageSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkycoinCheckMessageSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SkycoinCheckMessageSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkycoinCheckMessageSignature.Merge(dst, src)
}
func (m *SkycoinCheckMessageSignature) XXX_Size() int {
	return m.Size()
}
func (m *SkycoinCheckMessageSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_SkycoinCheckMessageSignature.DiscardUnknown(m)
}

var xxx_messageInfo_SkycoinCheckMessageSignature proto.InternalMessageInfo

func (m *SkycoinCheckMessageSignature) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

func (m *SkycoinCheckMessageSignature) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *SkycoinCheckMessageSignature) GetSignature() string {
	if m != nil && m.Signature != nil {
		return *m.Signature
	}
	return ""
}

// *
// Request: Sign a message digest using the given secret key.
// @next Failure
// @next ResponseSkycoinSignMessage
type SkycoinSignMessage struct {
	AddressN             *uint32  `protobuf:"varint,1,req,name=address_n,json=addressN" json:"address_n,omitempty"`
	Message              *string  `protobuf:"bytes,2,req,name=message" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SkycoinSignMessage) Reset()         { *m = SkycoinSignMessage{} }
func (m *SkycoinSignMessage) String() string { return proto.CompactTextString(m) }
func (*SkycoinSignMessage) ProtoMessage()    {}
func (*SkycoinSignMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{11}
}
func (m *SkycoinSignMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkycoinSignMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkycoinSignMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SkycoinSignMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkycoinSignMessage.Merge(dst, src)
}
func (m *SkycoinSignMessage) XXX_Size() int {
	return m.Size()
}
func (m *SkycoinSignMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SkycoinSignMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SkycoinSignMessage proto.InternalMessageInfo

func (m *SkycoinSignMessage) GetAddressN() uint32 {
	if m != nil && m.AddressN != nil {
		return *m.AddressN
	}
	return 0
}

func (m *SkycoinSignMessage) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

// *
// Response: Return the generated skycoin address
// @prev SkycoinAddress
type ResponseSkycoinSignMessage struct {
	SignedMessage        *string  `protobuf:"bytes,1,req,name=signed_message,json=signedMessage" json:"signed_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseSkycoinSignMessage) Reset()         { *m = ResponseSkycoinSignMessage{} }
func (m *ResponseSkycoinSignMessage) String() string { return proto.CompactTextString(m) }
func (*ResponseSkycoinSignMessage) ProtoMessage()    {}
func (*ResponseSkycoinSignMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{12}
}
func (m *ResponseSkycoinSignMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseSkycoinSignMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseSkycoinSignMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ResponseSkycoinSignMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseSkycoinSignMessage.Merge(dst, src)
}
func (m *ResponseSkycoinSignMessage) XXX_Size() int {
	return m.Size()
}
func (m *ResponseSkycoinSignMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseSkycoinSignMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseSkycoinSignMessage proto.InternalMessageInfo

func (m *ResponseSkycoinSignMessage) GetSignedMessage() string {
	if m != nil && m.SignedMessage != nil {
		return *m.SignedMessage
	}
	return ""
}

// *
// Request: Test if the device is alive, device sends back the message in Success response
// @next Success
type Ping struct {
	Message              *string  `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
	ButtonProtection     *bool    `protobuf:"varint,2,opt,name=button_protection,json=buttonProtection" json:"button_protection,omitempty"`
	PinProtection        *bool    `protobuf:"varint,3,opt,name=pin_protection,json=pinProtection" json:"pin_protection,omitempty"`
	PassphraseProtection *bool    `protobuf:"varint,4,opt,name=passphrase_protection,json=passphraseProtection" json:"passphrase_protection,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ping) Reset()         { *m = Ping{} }
func (m *Ping) String() string { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()    {}
func (*Ping) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{13}
}
func (m *Ping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Ping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ping.Merge(dst, src)
}
func (m *Ping) XXX_Size() int {
	return m.Size()
}
func (m *Ping) XXX_DiscardUnknown() {
	xxx_messageInfo_Ping.DiscardUnknown(m)
}

var xxx_messageInfo_Ping proto.InternalMessageInfo

func (m *Ping) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *Ping) GetButtonProtection() bool {
	if m != nil && m.ButtonProtection != nil {
		return *m.ButtonProtection
	}
	return false
}

func (m *Ping) GetPinProtection() bool {
	if m != nil && m.PinProtection != nil {
		return *m.PinProtection
	}
	return false
}

func (m *Ping) GetPassphraseProtection() bool {
	if m != nil && m.PassphraseProtection != nil {
		return *m.PassphraseProtection
	}
	return false
}

// *
// Response: Success of the previous request
type Success struct {
	MsgType              *MessageType `protobuf:"varint,1,opt,name=msg_type,json=msgType,enum=MessageType" json:"msg_type,omitempty"`
	Message              *string      `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Success) Reset()         { *m = Success{} }
func (m *Success) String() string { return proto.CompactTextString(m) }
func (*Success) ProtoMessage()    {}
func (*Success) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{14}
}
func (m *Success) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Success) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Success.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Success) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Success.Merge(dst, src)
}
func (m *Success) XXX_Size() int {
	return m.Size()
}
func (m *Success) XXX_DiscardUnknown() {
	xxx_messageInfo_Success.DiscardUnknown(m)
}

var xxx_messageInfo_Success proto.InternalMessageInfo

func (m *Success) GetMsgType() MessageType {
	if m != nil && m.MsgType != nil {
		return *m.MsgType
	}
	return MessageType_MessageType_Initialize
}

func (m *Success) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

// *
// Response: Failure of the previous request
type Failure struct {
	MsgType              *MessageType `protobuf:"varint,1,opt,name=msg_type,json=msgType,enum=MessageType" json:"msg_type,omitempty"`
	Code                 *FailureType `protobuf:"varint,2,opt,name=code,enum=FailureType" json:"code,omitempty"`
	Message              *string      `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Failure) Reset()         { *m = Failure{} }
func (m *Failure) String() string { return proto.CompactTextString(m) }
func (*Failure) ProtoMessage()    {}
func (*Failure) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{15}
}
func (m *Failure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Failure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Failure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Failure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Failure.Merge(dst, src)
}
func (m *Failure) XXX_Size() int {
	return m.Size()
}
func (m *Failure) XXX_DiscardUnknown() {
	xxx_messageInfo_Failure.DiscardUnknown(m)
}

var xxx_messageInfo_Failure proto.InternalMessageInfo

func (m *Failure) GetMsgType() MessageType {
	if m != nil && m.MsgType != nil {
		return *m.MsgType
	}
	return MessageType_MessageType_Initialize
}

func (m *Failure) GetCode() FailureType {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return FailureType_Failure_UnexpectedMessage
}

func (m *Failure) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

// *
// Response: Device is waiting for HW button press.
// @next ButtonAck
// @next Cancel
type ButtonRequest struct {
	Code                 *ButtonRequestType `protobuf:"varint,1,opt,name=code,enum=ButtonRequestType" json:"code,omitempty"`
	Data                 *string            `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ButtonRequest) Reset()         { *m = ButtonRequest{} }
func (m *ButtonRequest) String() string { return proto.CompactTextString(m) }
func (*ButtonRequest) ProtoMessage()    {}
func (*ButtonRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{16}
}
func (m *ButtonRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ButtonRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ButtonRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ButtonRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ButtonRequest.Merge(dst, src)
}
func (m *ButtonRequest) XXX_Size() int {
	return m.Size()
}
func (m *ButtonRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ButtonRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ButtonRequest proto.InternalMessageInfo

func (m *ButtonRequest) GetCode() ButtonRequestType {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return ButtonRequestType_ButtonRequest_Other
}

func (m *ButtonRequest) GetData() string {
	if m != nil && m.Data != nil {
		return *m.Data
	}
	return ""
}

// *
// Request: Computer agrees to wait for HW button press
// @prev ButtonRequest
type ButtonAck struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ButtonAck) Reset()         { *m = ButtonAck{} }
func (m *ButtonAck) String() string { return proto.CompactTextString(m) }
func (*ButtonAck) ProtoMessage()    {}
func (*ButtonAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{17}
}
func (m *ButtonAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ButtonAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ButtonAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ButtonAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ButtonAck.Merge(dst, src)
}
func (m *ButtonAck) XXX_Size() int {
	return m.Size()
}
func (m *ButtonAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ButtonAck.DiscardUnknown(m)
}

var xxx_messageInfo_ButtonAck proto.InternalMessageInfo

// *
// Response: Device is asking computer to show PIN matrix and awaits PIN encoded using this matrix scheme
// @next PinMatrixAck
// @next Cancel
type PinMatrixRequest struct {
	Type                 *PinMatrixRequestType `protobuf:"varint,1,opt,name=type,enum=PinMatrixRequestType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *PinMatrixRequest) Reset()         { *m = PinMatrixRequest{} }
func (m *PinMatrixRequest) String() string { return proto.CompactTextString(m) }
func (*PinMatrixRequest) ProtoMessage()    {}
func (*PinMatrixRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{18}
}
func (m *PinMatrixRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PinMatrixRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PinMatrixRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PinMatrixRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PinMatrixRequest.Merge(dst, src)
}
func (m *PinMatrixRequest) XXX_Size() int {
	return m.Size()
}
func (m *PinMatrixRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PinMatrixRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PinMatrixRequest proto.InternalMessageInfo

func (m *PinMatrixRequest) GetType() PinMatrixRequestType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return PinMatrixRequestType_PinMatrixRequestType_Current
}

// *
// Request: Computer responds with encoded PIN
// @prev PinMatrixRequest
type PinMatrixAck struct {
	Pin                  *string  `protobuf:"bytes,1,req,name=pin" json:"pin,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PinMatrixAck) Reset()         { *m = PinMatrixAck{} }
func (m *PinMatrixAck) String() string { return proto.CompactTextString(m) }
func (*PinMatrixAck) ProtoMessage()    {}
func (*PinMatrixAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{19}
}
func (m *PinMatrixAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PinMatrixAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PinMatrixAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PinMatrixAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PinMatrixAck.Merge(dst, src)
}
func (m *PinMatrixAck) XXX_Size() int {
	return m.Size()
}
func (m *PinMatrixAck) XXX_DiscardUnknown() {
	xxx_messageInfo_PinMatrixAck.DiscardUnknown(m)
}

var xxx_messageInfo_PinMatrixAck proto.InternalMessageInfo

func (m *PinMatrixAck) GetPin() string {
	if m != nil && m.Pin != nil {
		return *m.Pin
	}
	return ""
}

// *
// Request: Abort last operation that required user interaction
// @prev ButtonRequest
// @prev PinMatrixRequest
// @prev PassphraseRequest
type Cancel struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cancel) Reset()         { *m = Cancel{} }
func (m *Cancel) String() string { return proto.CompactTextString(m) }
func (*Cancel) ProtoMessage()    {}
func (*Cancel) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{20}
}
func (m *Cancel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cancel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cancel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Cancel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cancel.Merge(dst, src)
}
func (m *Cancel) XXX_Size() int {
	return m.Size()
}
func (m *Cancel) XXX_DiscardUnknown() {
	xxx_messageInfo_Cancel.DiscardUnknown(m)
}

var xxx_messageInfo_Cancel proto.InternalMessageInfo

// *
// Response: Device awaits encryption passphrase
// @next PassphraseAck
// @next Cancel
type PassphraseRequest struct {
	OnDevice             *bool    `protobuf:"varint,1,opt,name=on_device,json=onDevice" json:"on_device,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PassphraseRequest) Reset()         { *m = PassphraseRequest{} }
func (m *PassphraseRequest) String() string { return proto.CompactTextString(m) }
func (*PassphraseRequest) ProtoMessage()    {}
func (*PassphraseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{21}
}
func (m *PassphraseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PassphraseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PassphraseRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PassphraseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PassphraseRequest.Merge(dst, src)
}
func (m *PassphraseRequest) XXX_Size() int {
	return m.Size()
}
func (m *PassphraseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PassphraseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PassphraseRequest proto.InternalMessageInfo

func (m *PassphraseRequest) GetOnDevice() bool {
	if m != nil && m.OnDevice != nil {
		return *m.OnDevice
	}
	return false
}

// *
// Request: Send passphrase back
// @prev PassphraseRequest
// @next PassphraseStateRequest
type PassphraseAck struct {
	Passphrase           *string  `protobuf:"bytes,1,opt,name=passphrase" json:"passphrase,omitempty"`
	State                []byte   `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PassphraseAck) Reset()         { *m = PassphraseAck{} }
func (m *PassphraseAck) String() string { return proto.CompactTextString(m) }
func (*PassphraseAck) ProtoMessage()    {}
func (*PassphraseAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{22}
}
func (m *PassphraseAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PassphraseAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PassphraseAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PassphraseAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PassphraseAck.Merge(dst, src)
}
func (m *PassphraseAck) XXX_Size() int {
	return m.Size()
}
func (m *PassphraseAck) XXX_DiscardUnknown() {
	xxx_messageInfo_PassphraseAck.DiscardUnknown(m)
}

var xxx_messageInfo_PassphraseAck proto.InternalMessageInfo

func (m *PassphraseAck) GetPassphrase() string {
	if m != nil && m.Passphrase != nil {
		return *m.Passphrase
	}
	return ""
}

func (m *PassphraseAck) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

// *
// @prev PassphraseAck
// @next PassphraseStateAck
type PassphraseStateRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PassphraseStateRequest) Reset()         { *m = PassphraseStateRequest{} }
func (m *PassphraseStateRequest) String() string { return proto.CompactTextString(m) }
func (*PassphraseStateRequest) ProtoMessage()    {}
func (*PassphraseStateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{23}
}
func (m *PassphraseStateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PassphraseStateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PassphraseStateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PassphraseStateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PassphraseStateRequest.Merge(dst, src)
}
func (m *PassphraseStateRequest) XXX_Size() int {
	return m.Size()
}
func (m *PassphraseStateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PassphraseStateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PassphraseStateRequest proto.InternalMessageInfo

func (m *PassphraseStateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

// *
// @prev PassphraseStateRequest
type PassphraseStateAck struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PassphraseStateAck) Reset()         { *m = PassphraseStateAck{} }
func (m *PassphraseStateAck) String() string { return proto.CompactTextString(m) }
func (*PassphraseStateAck) ProtoMessage()    {}
func (*PassphraseStateAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{24}
}
func (m *PassphraseStateAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PassphraseStateAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PassphraseStateAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PassphraseStateAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PassphraseStateAck.Merge(dst, src)
}
func (m *PassphraseStateAck) XXX_Size() int {
	return m.Size()
}
func (m *PassphraseStateAck) XXX_DiscardUnknown() {
	xxx_messageInfo_PassphraseStateAck.DiscardUnknown(m)
}

var xxx_messageInfo_PassphraseStateAck proto.InternalMessageInfo

// *
// Request: Request a sample of random data generated by hardware RNG. May be used for testing.
// @next ButtonRequest
// @next Entropy
// @next Failure
type GetRawEntropy struct {
	Size_                *uint32  `protobuf:"varint,1,req,name=size" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRawEntropy) Reset()         { *m = GetRawEntropy{} }
func (m *GetRawEntropy) String() string { return proto.CompactTextString(m) }
func (*GetRawEntropy) ProtoMessage()    {}
func (*GetRawEntropy) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{25}
}
func (m *GetRawEntropy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRawEntropy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRawEntropy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetRawEntropy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRawEntropy.Merge(dst, src)
}
func (m *GetRawEntropy) XXX_Size() int {
	return m.Size()
}
func (m *GetRawEntropy) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRawEntropy.DiscardUnknown(m)
}

var xxx_messageInfo_GetRawEntropy proto.InternalMessageInfo

func (m *GetRawEntropy) GetSize_() uint32 {
	if m != nil && m.Size_ != nil {
		return *m.Size_
	}
	return 0
}

// *
// Request: Request a sample of salted random data. May be used for testing.
// @next ButtonRequest
// @next Entropy
// @next Failure
type GetMixedEntropy struct {
	Size_                *uint32  `protobuf:"varint,1,req,name=size" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMixedEntropy) Reset()         { *m = GetMixedEntropy{} }
func (m *GetMixedEntropy) String() string { return proto.CompactTextString(m) }
func (*GetMixedEntropy) ProtoMessage()    {}
func (*GetMixedEntropy) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{26}
}
func (m *GetMixedEntropy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMixedEntropy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMixedEntropy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetMixedEntropy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMixedEntropy.Merge(dst, src)
}
func (m *GetMixedEntropy) XXX_Size() int {
	return m.Size()
}
func (m *GetMixedEntropy) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMixedEntropy.DiscardUnknown(m)
}

var xxx_messageInfo_GetMixedEntropy proto.InternalMessageInfo

func (m *GetMixedEntropy) GetSize_() uint32 {
	if m != nil && m.Size_ != nil {
		return *m.Size_
	}
	return 0
}

// *
// Response: Reply with random data generated by internal RNG
// @prev GetRawEntropy
// @prev GetMixedEntropy
type Entropy struct {
	Entropy              []byte   `protobuf:"bytes,1,req,name=entropy" json:"entropy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Entropy) Reset()         { *m = Entropy{} }
func (m *Entropy) String() string { return proto.CompactTextString(m) }
func (*Entropy) ProtoMessage()    {}
func (*Entropy) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{27}
}
func (m *Entropy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entropy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entropy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Entropy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entropy.Merge(dst, src)
}
func (m *Entropy) XXX_Size() int {
	return m.Size()
}
func (m *Entropy) XXX_DiscardUnknown() {
	xxx_messageInfo_Entropy.DiscardUnknown(m)
}

var xxx_messageInfo_Entropy proto.InternalMessageInfo

func (m *Entropy) GetEntropy() []byte {
	if m != nil {
		return m.Entropy
	}
	return nil
}

// *
// Request: Request device to wipe all sensitive data and settings
// @next ButtonRequest
type WipeDevice struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WipeDevice) Reset()         { *m = WipeDevice{} }
func (m *WipeDevice) String() string { return proto.CompactTextString(m) }
func (*WipeDevice) ProtoMessage()    {}
func (*WipeDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{28}
}
func (m *WipeDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WipeDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WipeDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WipeDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WipeDevice.Merge(dst, src)
}
func (m *WipeDevice) XXX_Size() int {
	return m.Size()
}
func (m *WipeDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_WipeDevice.DiscardUnknown(m)
}

var xxx_messageInfo_WipeDevice proto.InternalMessageInfo

// *
// Request: Load seed and related internal settings from the computer
// @next ButtonRequest
// @next Success
// @next Failure
type LoadDevice struct {
	Mnemonic             *string     `protobuf:"bytes,1,opt,name=mnemonic" json:"mnemonic,omitempty"`
	Node                 *HDNodeType `protobuf:"bytes,2,opt,name=node" json:"node,omitempty"`
	Pin                  *string     `protobuf:"bytes,3,opt,name=pin" json:"pin,omitempty"`
	PassphraseProtection *bool       `protobuf:"varint,4,opt,name=passphrase_protection,json=passphraseProtection" json:"passphrase_protection,omitempty"`
	Language             *string     `protobuf:"bytes,5,opt,name=language,def=english" json:"language,omitempty"`
	Label                *string     `protobuf:"bytes,6,opt,name=label" json:"label,omitempty"`
	SkipChecksum         *bool       `protobuf:"varint,7,opt,name=skip_checksum,json=skipChecksum" json:"skip_checksum,omitempty"`
	U2FCounter           *uint32     `protobuf:"varint,8,opt,name=u2f_counter,json=u2fCounter" json:"u2f_counter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *LoadDevice) Reset()         { *m = LoadDevice{} }
func (m *LoadDevice) String() string { return proto.CompactTextString(m) }
func (*LoadDevice) ProtoMessage()    {}
func (*LoadDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{29}
}
func (m *LoadDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LoadDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadDevice.Merge(dst, src)
}
func (m *LoadDevice) XXX_Size() int {
	return m.Size()
}
func (m *LoadDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadDevice.DiscardUnknown(m)
}

var xxx_messageInfo_LoadDevice proto.InternalMessageInfo

const Default_LoadDevice_Language string = "english"

func (m *LoadDevice) GetMnemonic() string {
	if m != nil && m.Mnemonic != nil {
		return *m.Mnemonic
	}
	return ""
}

func (m *LoadDevice) GetNode() *HDNodeType {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *LoadDevice) GetPin() string {
	if m != nil && m.Pin != nil {
		return *m.Pin
	}
	return ""
}

func (m *LoadDevice) GetPassphraseProtection() bool {
	if m != nil && m.PassphraseProtection != nil {
		return *m.PassphraseProtection
	}
	return false
}

func (m *LoadDevice) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return Default_LoadDevice_Language
}

func (m *LoadDevice) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *LoadDevice) GetSkipChecksum() bool {
	if m != nil && m.SkipChecksum != nil {
		return *m.SkipChecksum
	}
	return false
}

func (m *LoadDevice) GetU2FCounter() uint32 {
	if m != nil && m.U2FCounter != nil {
		return *m.U2FCounter
	}
	return 0
}

// *
// Request: Ask device to do initialization involving user interaction
// @next EntropyRequest
// @next Failure
type ResetDevice struct {
	DisplayRandom        *bool    `protobuf:"varint,1,opt,name=display_random,json=displayRandom" json:"display_random,omitempty"`
	Strength             *uint32  `protobuf:"varint,2,opt,name=strength,def=256" json:"strength,omitempty"`
	PassphraseProtection *bool    `protobuf:"varint,3,opt,name=passphrase_protection,json=passphraseProtection" json:"passphrase_protection,omitempty"`
	PinProtection        *bool    `protobuf:"varint,4,opt,name=pin_protection,json=pinProtection" json:"pin_protection,omitempty"`
	Language             *string  `protobuf:"bytes,5,opt,name=language,def=english" json:"language,omitempty"`
	Label                *string  `protobuf:"bytes,6,opt,name=label" json:"label,omitempty"`
	U2FCounter           *uint32  `protobuf:"varint,7,opt,name=u2f_counter,json=u2fCounter" json:"u2f_counter,omitempty"`
	SkipBackup           *bool    `protobuf:"varint,8,opt,name=skip_backup,json=skipBackup" json:"skip_backup,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetDevice) Reset()         { *m = ResetDevice{} }
func (m *ResetDevice) String() string { return proto.CompactTextString(m) }
func (*ResetDevice) ProtoMessage()    {}
func (*ResetDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{30}
}
func (m *ResetDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ResetDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetDevice.Merge(dst, src)
}
func (m *ResetDevice) XXX_Size() int {
	return m.Size()
}
func (m *ResetDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetDevice.DiscardUnknown(m)
}

var xxx_messageInfo_ResetDevice proto.InternalMessageInfo

const Default_ResetDevice_Strength uint32 = 256
const Default_ResetDevice_Language string = "english"

func (m *ResetDevice) GetDisplayRandom() bool {
	if m != nil && m.DisplayRandom != nil {
		return *m.DisplayRandom
	}
	return false
}

func (m *ResetDevice) GetStrength() uint32 {
	if m != nil && m.Strength != nil {
		return *m.Strength
	}
	return Default_ResetDevice_Strength
}

func (m *ResetDevice) GetPassphraseProtection() bool {
	if m != nil && m.PassphraseProtection != nil {
		return *m.PassphraseProtection
	}
	return false
}

func (m *ResetDevice) GetPinProtection() bool {
	if m != nil && m.PinProtection != nil {
		return *m.PinProtection
	}
	return false
}

func (m *ResetDevice) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return Default_ResetDevice_Language
}

func (m *ResetDevice) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *ResetDevice) GetU2FCounter() uint32 {
	if m != nil && m.U2FCounter != nil {
		return *m.U2FCounter
	}
	return 0
}

func (m *ResetDevice) GetSkipBackup() bool {
	if m != nil && m.SkipBackup != nil {
		return *m.SkipBackup
	}
	return false
}

// *
// Request: Perform backup of the device seed if not backed up using ResetDevice
// @next ButtonRequest
type BackupDevice struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackupDevice) Reset()         { *m = BackupDevice{} }
func (m *BackupDevice) String() string { return proto.CompactTextString(m) }
func (*BackupDevice) ProtoMessage()    {}
func (*BackupDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{31}
}
func (m *BackupDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BackupDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupDevice.Merge(dst, src)
}
func (m *BackupDevice) XXX_Size() int {
	return m.Size()
}
func (m *BackupDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupDevice.DiscardUnknown(m)
}

var xxx_messageInfo_BackupDevice proto.InternalMessageInfo

// *
// Response: Ask for additional entropy from host computer
// @prev ResetDevice
// @next EntropyAck
type EntropyRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EntropyRequest) Reset()         { *m = EntropyRequest{} }
func (m *EntropyRequest) String() string { return proto.CompactTextString(m) }
func (*EntropyRequest) ProtoMessage()    {}
func (*EntropyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{32}
}
func (m *EntropyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntropyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntropyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EntropyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntropyRequest.Merge(dst, src)
}
func (m *EntropyRequest) XXX_Size() int {
	return m.Size()
}
func (m *EntropyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EntropyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EntropyRequest proto.InternalMessageInfo

// *
// Request: Provide additional entropy for seed generation function
// @prev EntropyRequest
// @next ButtonRequest
type EntropyAck struct {
	Entropy              []byte   `protobuf:"bytes,1,opt,name=entropy" json:"entropy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EntropyAck) Reset()         { *m = EntropyAck{} }
func (m *EntropyAck) String() string { return proto.CompactTextString(m) }
func (*EntropyAck) ProtoMessage()    {}
func (*EntropyAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{33}
}
func (m *EntropyAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntropyAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntropyAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EntropyAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntropyAck.Merge(dst, src)
}
func (m *EntropyAck) XXX_Size() int {
	return m.Size()
}
func (m *EntropyAck) XXX_DiscardUnknown() {
	xxx_messageInfo_EntropyAck.DiscardUnknown(m)
}

var xxx_messageInfo_EntropyAck proto.InternalMessageInfo

func (m *EntropyAck) GetEntropy() []byte {
	if m != nil {
		return m.Entropy
	}
	return nil
}

// *
// Request: Start recovery workflow asking user for specific words of mnemonic
// Used to recovery device safely even on untrusted computer.
// @next WordRequest
type RecoveryDevice struct {
	WordCount            *uint32  `protobuf:"varint,1,opt,name=word_count,json=wordCount" json:"word_count,omitempty"`
	PassphraseProtection *bool    `protobuf:"varint,2,opt,name=passphrase_protection,json=passphraseProtection" json:"passphrase_protection,omitempty"`
	PinProtection        *bool    `protobuf:"varint,3,opt,name=pin_protection,json=pinProtection" json:"pin_protection,omitempty"`
	Language             *string  `protobuf:"bytes,4,opt,name=language,def=english" json:"language,omitempty"`
	Label                *string  `protobuf:"bytes,5,opt,name=label" json:"label,omitempty"`
	DryRun               *bool    `protobuf:"varint,6,opt,name=dry_run,json=dryRun" json:"dry_run,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecoveryDevice) Reset()         { *m = RecoveryDevice{} }
func (m *RecoveryDevice) String() string { return proto.CompactTextString(m) }
func (*RecoveryDevice) ProtoMessage()    {}
func (*RecoveryDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{34}
}
func (m *RecoveryDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecoveryDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryDevice.Merge(dst, src)
}
func (m *RecoveryDevice) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryDevice.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryDevice proto.InternalMessageInfo

const Default_RecoveryDevice_Language string = "english"

func (m *RecoveryDevice) GetWordCount() uint32 {
	if m != nil && m.WordCount != nil {
		return *m.WordCount
	}
	return 0
}

func (m *RecoveryDevice) GetPassphraseProtection() bool {
	if m != nil && m.PassphraseProtection != nil {
		return *m.PassphraseProtection
	}
	return false
}

func (m *RecoveryDevice) GetPinProtection() bool {
	if m != nil && m.PinProtection != nil {
		return *m.PinProtection
	}
	return false
}

func (m *RecoveryDevice) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return Default_RecoveryDevice_Language
}

func (m *RecoveryDevice) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *RecoveryDevice) GetDryRun() bool {
	if m != nil && m.DryRun != nil {
		return *m.DryRun
	}
	return false
}

// *
// Response: Device is waiting for user to enter word of the mnemonic
// Its position is shown only on device's internal display.
// @prev RecoveryDevice
// @prev WordAck
type WordRequest struct {
	Type                 *WordRequestType `protobuf:"varint,1,opt,name=type,enum=WordRequestType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *WordRequest) Reset()         { *m = WordRequest{} }
func (m *WordRequest) String() string { return proto.CompactTextString(m) }
func (*WordRequest) ProtoMessage()    {}
func (*WordRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{35}
}
func (m *WordRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WordRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WordRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WordRequest.Merge(dst, src)
}
func (m *WordRequest) XXX_Size() int {
	return m.Size()
}
func (m *WordRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WordRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WordRequest proto.InternalMessageInfo

func (m *WordRequest) GetType() WordRequestType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return WordRequestType_WordRequestType_Plain
}

// *
// Request: Computer replies with word from the mnemonic
// @prev WordRequest
// @next WordRequest
// @next Success
// @next Failure
type WordAck struct {
	Word                 *string  `protobuf:"bytes,1,req,name=word" json:"word,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WordAck) Reset()         { *m = WordAck{} }
func (m *WordAck) String() string { return proto.CompactTextString(m) }
func (*WordAck) ProtoMessage()    {}
func (*WordAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{36}
}
func (m *WordAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WordAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WordAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WordAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WordAck.Merge(dst, src)
}
func (m *WordAck) XXX_Size() int {
	return m.Size()
}
func (m *WordAck) XXX_DiscardUnknown() {
	xxx_messageInfo_WordAck.DiscardUnknown(m)
}

var xxx_messageInfo_WordAck proto.InternalMessageInfo

func (m *WordAck) GetWord() string {
	if m != nil && m.Word != nil {
		return *m.Word
	}
	return ""
}

// *
// Request: Ask device to erase its firmware (so it can be replaced via FirmwareUpload)
// @start
// @next FirmwareRequest
type FirmwareErase struct {
	Length               *uint32  `protobuf:"varint,1,opt,name=length" json:"length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FirmwareErase) Reset()         { *m = FirmwareErase{} }
func (m *FirmwareErase) String() string { return proto.CompactTextString(m) }
func (*FirmwareErase) ProtoMessage()    {}
func (*FirmwareErase) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{37}
}
func (m *FirmwareErase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirmwareErase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirmwareErase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirmwareErase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirmwareErase.Merge(dst, src)
}
func (m *FirmwareErase) XXX_Size() int {
	return m.Size()
}
func (m *FirmwareErase) XXX_DiscardUnknown() {
	xxx_messageInfo_FirmwareErase.DiscardUnknown(m)
}

var xxx_messageInfo_FirmwareErase proto.InternalMessageInfo

func (m *FirmwareErase) GetLength() uint32 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

// *
// Response: Ask for firmware chunk
// @next FirmwareUpload
type FirmwareRequest struct {
	Offset               *uint32  `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	Length               *uint32  `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FirmwareRequest) Reset()         { *m = FirmwareRequest{} }
func (m *FirmwareRequest) String() string { return proto.CompactTextString(m) }
func (*FirmwareRequest) ProtoMessage()    {}
func (*FirmwareRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{38}
}
func (m *FirmwareRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirmwareRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirmwareRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirmwareRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirmwareRequest.Merge(dst, src)
}
func (m *FirmwareRequest) XXX_Size() int {
	return m.Size()
}
func (m *FirmwareRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FirmwareRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FirmwareRequest proto.InternalMessageInfo

func (m *FirmwareRequest) GetOffset() uint32 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *FirmwareRequest) GetLength() uint32 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

// *
// Request: Ask device to upload its firmware
// @start
// @next FirmwareUpload
type FirmwareUpload struct {
	Payload              []byte   `protobuf:"bytes,1,opt,name=payload" json:"payload,omitempty"`
	Hash                 []byte   `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FirmwareUpload) Reset()         { *m = FirmwareUpload{} }
func (m *FirmwareUpload) String() string { return proto.CompactTextString(m) }
func (*FirmwareUpload) ProtoMessage()    {}
func (*FirmwareUpload) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{39}
}
func (m *FirmwareUpload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirmwareUpload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirmwareUpload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirmwareUpload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirmwareUpload.Merge(dst, src)
}
func (m *FirmwareUpload) XXX_Size() int {
	return m.Size()
}
func (m *FirmwareUpload) XXX_DiscardUnknown() {
	xxx_messageInfo_FirmwareUpload.DiscardUnknown(m)
}

var xxx_messageInfo_FirmwareUpload proto.InternalMessageInfo

func (m *FirmwareUpload) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *FirmwareUpload) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// *
// Request: Ask device to sign transactions one by one
// @next ResponseSkycoinSignMessage
// @next Success
// @next Failure
type TransactionSign struct {
	NbIn                 *uint32                     `protobuf:"varint,1,req,name=nbIn" json:"nbIn,omitempty"`
	TransactionIn        []*SkycoinTransactionInput  `protobuf:"bytes,2,rep,name=transactionIn" json:"transactionIn,omitempty"`
	NbOut                *uint32                     `protobuf:"varint,3,req,name=nbOut" json:"nbOut,omitempty"`
	TransactionOut       []*SkycoinTransactionOutput `protobuf:"bytes,4,rep,name=transactionOut" json:"transactionOut,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *TransactionSign) Reset()         { *m = TransactionSign{} }
func (m *TransactionSign) String() string { return proto.CompactTextString(m) }
func (*TransactionSign) ProtoMessage()    {}
func (*TransactionSign) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{40}
}
func (m *TransactionSign) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionSign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionSign.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TransactionSign) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionSign.Merge(dst, src)
}
func (m *TransactionSign) XXX_Size() int {
	return m.Size()
}
func (m *TransactionSign) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionSign.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionSign proto.InternalMessageInfo

func (m *TransactionSign) GetNbIn() uint32 {
	if m != nil && m.NbIn != nil {
		return *m.NbIn
	}
	return 0
}

func (m *TransactionSign) GetTransactionIn() []*SkycoinTransactionInput {
	if m != nil {
		return m.TransactionIn
	}
	return nil
}

func (m *TransactionSign) GetNbOut() uint32 {
	if m != nil && m.NbOut != nil {
		return *m.NbOut
	}
	return 0
}

func (m *TransactionSign) GetTransactionOut() []*SkycoinTransactionOutput {
	if m != nil {
		return m.TransactionOut
	}
	return nil
}

type SignTx struct {
	OutputsCount         *uint32  `protobuf:"varint,1,req,name=outputs_count,json=outputsCount" json:"outputs_count,omitempty"`
	InputsCount          *uint32  `protobuf:"varint,2,req,name=inputs_count,json=inputsCount" json:"inputs_count,omitempty"`
	CoinName             *string  `protobuf:"bytes,3,opt,name=coin_name,json=coinName,def=SKY" json:"coin_name,omitempty"`
	Version              *uint32  `protobuf:"varint,4,opt,name=version,def=1" json:"version,omitempty"`
	LockTime             *uint32  `protobuf:"varint,5,opt,name=lock_time,json=lockTime,def=0" json:"lock_time,omitempty"`
	TxHash               *string  `protobuf:"bytes,6,opt,name=tx_hash,json=txHash" json:"tx_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignTx) Reset()         { *m = SignTx{} }
func (m *SignTx) String() string { return proto.CompactTextString(m) }
func (*SignTx) ProtoMessage()    {}
func (*SignTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{41}
}
func (m *SignTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SignTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignTx.Merge(dst, src)
}
func (m *SignTx) XXX_Size() int {
	return m.Size()
}
func (m *SignTx) XXX_DiscardUnknown() {
	xxx_messageInfo_SignTx.DiscardUnknown(m)
}

var xxx_messageInfo_SignTx proto.InternalMessageInfo

const Default_SignTx_CoinName string = "SKY"
const Default_SignTx_Version uint32 = 1
const Default_SignTx_LockTime uint32 = 0

func (m *SignTx) GetOutputsCount() uint32 {
	if m != nil && m.OutputsCount != nil {
		return *m.OutputsCount
	}
	return 0
}

func (m *SignTx) GetInputsCount() uint32 {
	if m != nil && m.InputsCount != nil {
		return *m.InputsCount
	}
	return 0
}

func (m *SignTx) GetCoinName() string {
	if m != nil && m.CoinName != nil {
		return *m.CoinName
	}
	return Default_SignTx_CoinName
}

func (m *SignTx) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_SignTx_Version
}

func (m *SignTx) GetLockTime() uint32 {
	if m != nil && m.LockTime != nil {
		return *m.LockTime
	}
	return Default_SignTx_LockTime
}

func (m *SignTx) GetTxHash() string {
	if m != nil && m.TxHash != nil {
		return *m.TxHash
	}
	return ""
}

type TxRequest struct {
	RequestType          *TxRequest_RequestType                 `protobuf:"varint,1,req,name=request_type,json=requestType,enum=TxRequest_RequestType" json:"request_type,omitempty"`
	Details              *TxRequest_TxRequestDetailsType        `protobuf:"bytes,2,opt,name=details" json:"details,omitempty"`
	SignResult           []*TxRequest_TxRequestSignResponseType `protobuf:"bytes,3,rep,name=sign_result,json=signResult" json:"sign_result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *TxRequest) Reset()         { *m = TxRequest{} }
func (m *TxRequest) String() string { return proto.CompactTextString(m) }
func (*TxRequest) ProtoMessage()    {}
func (*TxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{42}
}
func (m *TxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRequest.Merge(dst, src)
}
func (m *TxRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxRequest proto.InternalMessageInfo

func (m *TxRequest) GetRequestType() TxRequest_RequestType {
	if m != nil && m.RequestType != nil {
		return *m.RequestType
	}
	return TxRequest_TXINPUT
}

func (m *TxRequest) GetDetails() *TxRequest_TxRequestDetailsType {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *TxRequest) GetSignResult() []*TxRequest_TxRequestSignResponseType {
	if m != nil {
		return m.SignResult
	}
	return nil
}

// *
// Structure representing request details
type TxRequest_TxRequestDetailsType struct {
	RequestIndex         *uint32  `protobuf:"varint,1,opt,name=request_index,json=requestIndex" json:"request_index,omitempty"`
	TxHash               *string  `protobuf:"bytes,2,opt,name=tx_hash,json=txHash" json:"tx_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxRequest_TxRequestDetailsType) Reset()         { *m = TxRequest_TxRequestDetailsType{} }
func (m *TxRequest_TxRequestDetailsType) String() string { return proto.CompactTextString(m) }
func (*TxRequest_TxRequestDetailsType) ProtoMessage()    {}
func (*TxRequest_TxRequestDetailsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{42, 0}
}
func (m *TxRequest_TxRequestDetailsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRequest_TxRequestDetailsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRequest_TxRequestDetailsType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxRequest_TxRequestDetailsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRequest_TxRequestDetailsType.Merge(dst, src)
}
func (m *TxRequest_TxRequestDetailsType) XXX_Size() int {
	return m.Size()
}
func (m *TxRequest_TxRequestDetailsType) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRequest_TxRequestDetailsType.DiscardUnknown(m)
}

var xxx_messageInfo_TxRequest_TxRequestDetailsType proto.InternalMessageInfo

func (m *TxRequest_TxRequestDetailsType) GetRequestIndex() uint32 {
	if m != nil && m.RequestIndex != nil {
		return *m.RequestIndex
	}
	return 0
}

func (m *TxRequest_TxRequestDetailsType) GetTxHash() string {
	if m != nil && m.TxHash != nil {
		return *m.TxHash
	}
	return ""
}

// *
// Structure representing serialized data
type TxRequest_TxRequestSignResponseType struct {
	SignatureIndex       *uint32  `protobuf:"varint,1,opt,name=signature_index,json=signatureIndex" json:"signature_index,omitempty"`
	Signature            *string  `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxRequest_TxRequestSignResponseType) Reset()         { *m = TxRequest_TxRequestSignResponseType{} }
func (m *TxRequest_TxRequestSignResponseType) String() string { return proto.CompactTextString(m) }
func (*TxRequest_TxRequestSignResponseType) ProtoMessage()    {}
func (*TxRequest_TxRequestSignResponseType) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{42, 1}
}
func (m *TxRequest_TxRequestSignResponseType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRequest_TxRequestSignResponseType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRequest_TxRequestSignResponseType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxRequest_TxRequestSignResponseType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRequest_TxRequestSignResponseType.Merge(dst, src)
}
func (m *TxRequest_TxRequestSignResponseType) XXX_Size() int {
	return m.Size()
}
func (m *TxRequest_TxRequestSignResponseType) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRequest_TxRequestSignResponseType.DiscardUnknown(m)
}

var xxx_messageInfo_TxRequest_TxRequestSignResponseType proto.InternalMessageInfo

func (m *TxRequest_TxRequestSignResponseType) GetSignatureIndex() uint32 {
	if m != nil && m.SignatureIndex != nil {
		return *m.SignatureIndex
	}
	return 0
}

func (m *TxRequest_TxRequestSignResponseType) GetSignature() string {
	if m != nil && m.Signature != nil {
		return *m.Signature
	}
	return ""
}

type TxAck struct {
	Tx                   *TxAck_TransactionType `protobuf:"bytes,1,opt,name=tx" json:"tx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TxAck) Reset()         { *m = TxAck{} }
func (m *TxAck) String() string { return proto.CompactTextString(m) }
func (*TxAck) ProtoMessage()    {}
func (*TxAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{43}
}
func (m *TxAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxAck.Merge(dst, src)
}
func (m *TxAck) XXX_Size() int {
	return m.Size()
}
func (m *TxAck) XXX_DiscardUnknown() {
	xxx_messageInfo_TxAck.DiscardUnknown(m)
}

var xxx_messageInfo_TxAck proto.InternalMessageInfo

func (m *TxAck) GetTx() *TxAck_TransactionType {
	if m != nil {
		return m.Tx
	}
	return nil
}

// *
// Structure representing transaction
type TxAck_TransactionType struct {
	Version              *uint32                               `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	Inputs               []*TxAck_TransactionType_TxInputType  `protobuf:"bytes,2,rep,name=inputs" json:"inputs,omitempty"`
	LockTime             *uint32                               `protobuf:"varint,4,opt,name=lock_time,json=lockTime" json:"lock_time,omitempty"`
	Outputs              []*TxAck_TransactionType_TxOutputType `protobuf:"bytes,5,rep,name=outputs" json:"outputs,omitempty"`
	InputsCnt            *uint32                               `protobuf:"varint,6,opt,name=inputs_cnt,json=inputsCnt" json:"inputs_cnt,omitempty"`
	OutputsCnt           *uint32                               `protobuf:"varint,7,opt,name=outputs_cnt,json=outputsCnt" json:"outputs_cnt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *TxAck_TransactionType) Reset()         { *m = TxAck_TransactionType{} }
func (m *TxAck_TransactionType) String() string { return proto.CompactTextString(m) }
func (*TxAck_TransactionType) ProtoMessage()    {}
func (*TxAck_TransactionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{43, 0}
}
func (m *TxAck_TransactionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxAck_TransactionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxAck_TransactionType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxAck_TransactionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxAck_TransactionType.Merge(dst, src)
}
func (m *TxAck_TransactionType) XXX_Size() int {
	return m.Size()
}
func (m *TxAck_TransactionType) XXX_DiscardUnknown() {
	xxx_messageInfo_TxAck_TransactionType.DiscardUnknown(m)
}

var xxx_messageInfo_TxAck_TransactionType proto.InternalMessageInfo

func (m *TxAck_TransactionType) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *TxAck_TransactionType) GetInputs() []*TxAck_TransactionType_TxInputType {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *TxAck_TransactionType) GetLockTime() uint32 {
	if m != nil && m.LockTime != nil {
		return *m.LockTime
	}
	return 0
}

func (m *TxAck_TransactionType) GetOutputs() []*TxAck_TransactionType_TxOutputType {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *TxAck_TransactionType) GetInputsCnt() uint32 {
	if m != nil && m.InputsCnt != nil {
		return *m.InputsCnt
	}
	return 0
}

func (m *TxAck_TransactionType) GetOutputsCnt() uint32 {
	if m != nil && m.OutputsCnt != nil {
		return *m.OutputsCnt
	}
	return 0
}

// *
// Structure representing transaction input
type TxAck_TransactionType_TxInputType struct {
	AddressN             []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	HashIn               *string  `protobuf:"bytes,2,req,name=hashIn" json:"hashIn,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxAck_TransactionType_TxInputType) Reset()         { *m = TxAck_TransactionType_TxInputType{} }
func (m *TxAck_TransactionType_TxInputType) String() string { return proto.CompactTextString(m) }
func (*TxAck_TransactionType_TxInputType) ProtoMessage()    {}
func (*TxAck_TransactionType_TxInputType) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{43, 0, 0}
}
func (m *TxAck_TransactionType_TxInputType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxAck_TransactionType_TxInputType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxAck_TransactionType_TxInputType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxAck_TransactionType_TxInputType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxAck_TransactionType_TxInputType.Merge(dst, src)
}
func (m *TxAck_TransactionType_TxInputType) XXX_Size() int {
	return m.Size()
}
func (m *TxAck_TransactionType_TxInputType) XXX_DiscardUnknown() {
	xxx_messageInfo_TxAck_TransactionType_TxInputType.DiscardUnknown(m)
}

var xxx_messageInfo_TxAck_TransactionType_TxInputType proto.InternalMessageInfo

func (m *TxAck_TransactionType_TxInputType) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *TxAck_TransactionType_TxInputType) GetHashIn() string {
	if m != nil && m.HashIn != nil {
		return *m.HashIn
	}
	return ""
}

// *
// Structure representing transaction output
type TxAck_TransactionType_TxOutputType struct {
	Address              *string  `protobuf:"bytes,1,req,name=address" json:"address,omitempty"`
	AddressN             []uint32 `protobuf:"varint,2,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	Coins                *uint64  `protobuf:"varint,3,req,name=coins" json:"coins,omitempty"`
	Hours                *uint64  `protobuf:"varint,4,req,name=hours" json:"hours,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxAck_TransactionType_TxOutputType) Reset()         { *m = TxAck_TransactionType_TxOutputType{} }
func (m *TxAck_TransactionType_TxOutputType) String() string { return proto.CompactTextString(m) }
func (*TxAck_TransactionType_TxOutputType) ProtoMessage()    {}
func (*TxAck_TransactionType_TxOutputType) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_dc51b2d2f6000af7, []int{43, 0, 1}
}
func (m *TxAck_TransactionType_TxOutputType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxAck_TransactionType_TxOutputType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxAck_TransactionType_TxOutputType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxAck_TransactionType_TxOutputType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxAck_TransactionType_TxOutputType.Merge(dst, src)
}
func (m *TxAck_TransactionType_TxOutputType) XXX_Size() int {
	return m.Size()
}
func (m *TxAck_TransactionType_TxOutputType) XXX_DiscardUnknown() {
	xxx_messageInfo_TxAck_TransactionType_TxOutputType.DiscardUnknown(m)
}

var xxx_messageInfo_TxAck_TransactionType_TxOutputType proto.InternalMessageInfo

func (m *TxAck_TransactionType_TxOutputType) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

func (m *TxAck_TransactionType_TxOutputType) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *TxAck_TransactionType_TxOutputType) GetCoins() uint64 {
	if m != nil && m.Coins != nil {
		return *m.Coins
	}
	return 0
}

func (m *TxAck_TransactionType_TxOutputType) GetHours() uint64 {
	if m != nil && m.Hours != nil {
		return *m.Hours
	}
	return 0
}

func init() {
	proto.RegisterType((*Initialize)(nil), "Initialize")
	proto.RegisterType((*GetFeatures)(nil), "GetFeatures")
	proto.RegisterType((*Features)(nil), "Features")
	proto.RegisterType((*ApplySettings)(nil), "ApplySettings")
	proto.RegisterType((*GenerateMnemonic)(nil), "GenerateMnemonic")
	proto.RegisterType((*SetMnemonic)(nil), "SetMnemonic")
	proto.RegisterType((*ChangePin)(nil), "ChangePin")
	proto.RegisterType((*SkycoinAddress)(nil), "SkycoinAddress")
	proto.RegisterType((*ResponseSkycoinAddress)(nil), "ResponseSkycoinAddress")
	proto.RegisterType((*ResponseTransactionSign)(nil), "ResponseTransactionSign")
	proto.RegisterType((*SkycoinCheckMessageSignature)(nil), "SkycoinCheckMessageSignature")
	proto.RegisterType((*SkycoinSignMessage)(nil), "SkycoinSignMessage")
	proto.RegisterType((*ResponseSkycoinSignMessage)(nil), "ResponseSkycoinSignMessage")
	proto.RegisterType((*Ping)(nil), "Ping")
	proto.RegisterType((*Success)(nil), "Success")
	proto.RegisterType((*Failure)(nil), "Failure")
	proto.RegisterType((*ButtonRequest)(nil), "ButtonRequest")
	proto.RegisterType((*ButtonAck)(nil), "ButtonAck")
	proto.RegisterType((*PinMatrixRequest)(nil), "PinMatrixRequest")
	proto.RegisterType((*PinMatrixAck)(nil), "PinMatrixAck")
	proto.RegisterType((*Cancel)(nil), "Cancel")
	proto.RegisterType((*PassphraseRequest)(nil), "PassphraseRequest")
	proto.RegisterType((*PassphraseAck)(nil), "PassphraseAck")
	proto.RegisterType((*PassphraseStateRequest)(nil), "PassphraseStateRequest")
	proto.RegisterType((*PassphraseStateAck)(nil), "PassphraseStateAck")
	proto.RegisterType((*GetRawEntropy)(nil), "GetRawEntropy")
	proto.RegisterType((*GetMixedEntropy)(nil), "GetMixedEntropy")
	proto.RegisterType((*Entropy)(nil), "Entropy")
	proto.RegisterType((*WipeDevice)(nil), "WipeDevice")
	proto.RegisterType((*LoadDevice)(nil), "LoadDevice")
	proto.RegisterType((*ResetDevice)(nil), "ResetDevice")
	proto.RegisterType((*BackupDevice)(nil), "BackupDevice")
	proto.RegisterType((*EntropyRequest)(nil), "EntropyRequest")
	proto.RegisterType((*EntropyAck)(nil), "EntropyAck")
	proto.RegisterType((*RecoveryDevice)(nil), "RecoveryDevice")
	proto.RegisterType((*WordRequest)(nil), "WordRequest")
	proto.RegisterType((*WordAck)(nil), "WordAck")
	proto.RegisterType((*FirmwareErase)(nil), "FirmwareErase")
	proto.RegisterType((*FirmwareRequest)(nil), "FirmwareRequest")
	proto.RegisterType((*FirmwareUpload)(nil), "FirmwareUpload")
	proto.RegisterType((*TransactionSign)(nil), "TransactionSign")
	proto.RegisterType((*SignTx)(nil), "SignTx")
	proto.RegisterType((*TxRequest)(nil), "TxRequest")
	proto.RegisterType((*TxRequest_TxRequestDetailsType)(nil), "TxRequest.TxRequestDetailsType")
	proto.RegisterType((*TxRequest_TxRequestSignResponseType)(nil), "TxRequest.TxRequestSignResponseType")
	proto.RegisterType((*TxAck)(nil), "TxAck")
	proto.RegisterType((*TxAck_TransactionType)(nil), "TxAck.TransactionType")
	proto.RegisterType((*TxAck_TransactionType_TxInputType)(nil), "TxAck.TransactionType.TxInputType")
	proto.RegisterType((*TxAck_TransactionType_TxOutputType)(nil), "TxAck.TransactionType.TxOutputType")
	proto.RegisterEnum("MessageType", MessageType_name, MessageType_value)
	proto.RegisterEnum("TxRequest_RequestType", TxRequest_RequestType_name, TxRequest_RequestType_value)
}
func (m *Initialize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Initialize) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetFeatures) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFeatures) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Features) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Features) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Vendor != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Vendor)))
		i += copy(dAtA[i:], *m.Vendor)
	}
	if m.MajorVersion != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.MajorVersion))
	}
	if m.MinorVersion != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.MinorVersion))
	}
	if m.PatchVersion != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.PatchVersion))
	}
	if m.BootloaderMode != nil {
		dAtA[i] = 0x28
		i++
		if *m.BootloaderMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DeviceId != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.DeviceId)))
		i += copy(dAtA[i:], *m.DeviceId)
	}
	if m.PinProtection != nil {
		dAtA[i] = 0x38
		i++
		if *m.PinProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PassphraseProtection != nil {
		dAtA[i] = 0x40
		i++
		if *m.PassphraseProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Language != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Language)))
		i += copy(dAtA[i:], *m.Language)
	}
	if m.Label != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Label)))
		i += copy(dAtA[i:], *m.Label)
	}
	if m.Initialized != nil {
		dAtA[i] = 0x60
		i++
		if *m.Initialized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BootloaderHash != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.BootloaderHash)))
		i += copy(dAtA[i:], m.BootloaderHash)
	}
	if m.PinCached != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if *m.PinCached {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PassphraseCached != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if *m.PassphraseCached {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FirmwarePresent != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if *m.FirmwarePresent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NeedsBackup != nil {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if *m.NeedsBackup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Model != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Model)))
		i += copy(dAtA[i:], *m.Model)
	}
	if m.FwMajor != nil {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.FwMajor))
	}
	if m.FwMinor != nil {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.FwMinor))
	}
	if m.FwPatch != nil {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.FwPatch))
	}
	if m.FwVersionHead != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.FwVersionHead)))
		i += copy(dAtA[i:], *m.FwVersionHead)
	}
	if m.FwVendor != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.FwVendor)))
		i += copy(dAtA[i:], *m.FwVendor)
	}
	if m.FwVendorKeys != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.FwVendorKeys)))
		i += copy(dAtA[i:], m.FwVendorKeys)
	}
	if m.UnfinishedBackup != nil {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		if *m.UnfinishedBackup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FirmwareFeatures != nil {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.FirmwareFeatures))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ApplySettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplySettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Language != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Language)))
		i += copy(dAtA[i:], *m.Language)
	}
	if m.Label != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Label)))
		i += copy(dAtA[i:], *m.Label)
	}
	if m.UsePassphrase != nil {
		dAtA[i] = 0x18
		i++
		if *m.UsePassphrase {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Homescreen != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Homescreen)))
		i += copy(dAtA[i:], m.Homescreen)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GenerateMnemonic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateMnemonic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PassphraseProtection != nil {
		dAtA[i] = 0x8
		i++
		if *m.PassphraseProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WordCount != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.WordCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetMnemonic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetMnemonic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mnemonic == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("mnemonic")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Mnemonic)))
		i += copy(dAtA[i:], *m.Mnemonic)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChangePin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Remove != nil {
		dAtA[i] = 0x8
		i++
		if *m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SkycoinAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkycoinAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AddressN == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("address_n")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.AddressN))
	}
	if m.StartIndex != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.StartIndex))
	}
	if m.ConfirmAddress != nil {
		dAtA[i] = 0x18
		i++
		if *m.ConfirmAddress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResponseSkycoinAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseSkycoinAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResponseTransactionSign) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseTransactionSign) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for _, s := range m.Signatures {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Padding == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("padding")
	} else {
		dAtA[i] = 0x10
		i++
		if *m.Padding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SkycoinCheckMessageSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkycoinCheckMessageSignature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("address")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Address)))
		i += copy(dAtA[i:], *m.Address)
	}
	if m.Message == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("message")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Message)))
		i += copy(dAtA[i:], *m.Message)
	}
	if m.Signature == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("signature")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Signature)))
		i += copy(dAtA[i:], *m.Signature)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SkycoinSignMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkycoinSignMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AddressN == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("address_n")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.AddressN))
	}
	if m.Message == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("message")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Message)))
		i += copy(dAtA[i:], *m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResponseSkycoinSignMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseSkycoinSignMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SignedMessage == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("signed_message")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.SignedMessage)))
		i += copy(dAtA[i:], *m.SignedMessage)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Ping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Message)))
		i += copy(dAtA[i:], *m.Message)
	}
	if m.ButtonProtection != nil {
		dAtA[i] = 0x10
		i++
		if *m.ButtonProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PinProtection != nil {
		dAtA[i] = 0x18
		i++
		if *m.PinProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PassphraseProtection != nil {
		dAtA[i] = 0x20
		i++
		if *m.PassphraseProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Success) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Success) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MsgType != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.MsgType))
	}
	if m.Message != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Message)))
		i += copy(dAtA[i:], *m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Failure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Failure) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MsgType != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.MsgType))
	}
	if m.Code != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Code))
	}
	if m.Message != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Message)))
		i += copy(dAtA[i:], *m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ButtonRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ButtonRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Code))
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Data)))
		i += copy(dAtA[i:], *m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ButtonAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ButtonAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PinMatrixRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PinMatrixRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PinMatrixAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PinMatrixAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pin == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("pin")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Pin)))
		i += copy(dAtA[i:], *m.Pin)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Cancel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cancel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PassphraseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassphraseRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OnDevice != nil {
		dAtA[i] = 0x8
		i++
		if *m.OnDevice {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PassphraseAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassphraseAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Passphrase != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Passphrase)))
		i += copy(dAtA[i:], *m.Passphrase)
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PassphraseStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassphraseStateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PassphraseStateAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassphraseStateAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetRawEntropy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRawEntropy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Size_ == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("size")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Size_))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetMixedEntropy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMixedEntropy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Size_ == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("size")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Size_))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Entropy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entropy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Entropy == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("entropy")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Entropy)))
		i += copy(dAtA[i:], m.Entropy)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WipeDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WipeDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoadDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mnemonic != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Mnemonic)))
		i += copy(dAtA[i:], *m.Mnemonic)
	}
	if m.Node != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Node.Size()))
		n1, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Pin != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Pin)))
		i += copy(dAtA[i:], *m.Pin)
	}
	if m.PassphraseProtection != nil {
		dAtA[i] = 0x20
		i++
		if *m.PassphraseProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Language != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Language)))
		i += copy(dAtA[i:], *m.Language)
	}
	if m.Label != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Label)))
		i += copy(dAtA[i:], *m.Label)
	}
	if m.SkipChecksum != nil {
		dAtA[i] = 0x38
		i++
		if *m.SkipChecksum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.U2FCounter != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.U2FCounter))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResetDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DisplayRandom != nil {
		dAtA[i] = 0x8
		i++
		if *m.DisplayRandom {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Strength != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Strength))
	}
	if m.PassphraseProtection != nil {
		dAtA[i] = 0x18
		i++
		if *m.PassphraseProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PinProtection != nil {
		dAtA[i] = 0x20
		i++
		if *m.PinProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Language != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Language)))
		i += copy(dAtA[i:], *m.Language)
	}
	if m.Label != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Label)))
		i += copy(dAtA[i:], *m.Label)
	}
	if m.U2FCounter != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.U2FCounter))
	}
	if m.SkipBackup != nil {
		dAtA[i] = 0x40
		i++
		if *m.SkipBackup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BackupDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EntropyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntropyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EntropyAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntropyAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Entropy != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Entropy)))
		i += copy(dAtA[i:], m.Entropy)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RecoveryDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WordCount != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.WordCount))
	}
	if m.PassphraseProtection != nil {
		dAtA[i] = 0x10
		i++
		if *m.PassphraseProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PinProtection != nil {
		dAtA[i] = 0x18
		i++
		if *m.PinProtection {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Language != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Language)))
		i += copy(dAtA[i:], *m.Language)
	}
	if m.Label != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Label)))
		i += copy(dAtA[i:], *m.Label)
	}
	if m.DryRun != nil {
		dAtA[i] = 0x30
		i++
		if *m.DryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WordRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WordRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WordAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WordAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Word == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("word")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Word)))
		i += copy(dAtA[i:], *m.Word)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirmwareErase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirmwareErase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Length != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Length))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirmwareRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirmwareRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Offset != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Offset))
	}
	if m.Length != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Length))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirmwareUpload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirmwareUpload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	if m.Hash != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionSign) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionSign) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NbIn == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("nbIn")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.NbIn))
	}
	if len(m.TransactionIn) > 0 {
		for _, msg := range m.TransactionIn {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NbOut == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("nbOut")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.NbOut))
	}
	if len(m.TransactionOut) > 0 {
		for _, msg := range m.TransactionOut {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignTx) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OutputsCount == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("outputs_count")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.OutputsCount))
	}
	if m.InputsCount == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("inputs_count")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.InputsCount))
	}
	if m.CoinName != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.CoinName)))
		i += copy(dAtA[i:], *m.CoinName)
	}
	if m.Version != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Version))
	}
	if m.LockTime != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.LockTime))
	}
	if m.TxHash != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.TxHash)))
		i += copy(dAtA[i:], *m.TxHash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestType == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("request_type")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.RequestType))
	}
	if m.Details != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Details.Size()))
		n2, err := m.Details.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.SignResult) > 0 {
		for _, msg := range m.SignResult {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxRequest_TxRequestDetailsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRequest_TxRequestDetailsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestIndex != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.RequestIndex))
	}
	if m.TxHash != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.TxHash)))
		i += copy(dAtA[i:], *m.TxHash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxRequest_TxRequestSignResponseType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRequest_TxRequestSignResponseType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SignatureIndex != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.SignatureIndex))
	}
	if m.Signature != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Signature)))
		i += copy(dAtA[i:], *m.Signature)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tx != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Tx.Size()))
		n3, err := m.Tx.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxAck_TransactionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxAck_TransactionType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Version))
	}
	if len(m.Inputs) > 0 {
		for _, msg := range m.Inputs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LockTime != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.LockTime))
	}
	if len(m.Outputs) > 0 {
		for _, msg := range m.Outputs {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InputsCnt != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.InputsCnt))
	}
	if m.OutputsCnt != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.OutputsCnt))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxAck_TransactionType_TxInputType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxAck_TransactionType_TxInputType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AddressN) > 0 {
		for _, num := range m.AddressN {
			dAtA[i] = 0x8
			i++
			i = encodeVarintMessages(dAtA, i, uint64(num))
		}
	}
	if m.HashIn == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("hashIn")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.HashIn)))
		i += copy(dAtA[i:], *m.HashIn)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxAck_TransactionType_TxOutputType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxAck_TransactionType_TxOutputType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("address")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(*m.Address)))
		i += copy(dAtA[i:], *m.Address)
	}
	if len(m.AddressN) > 0 {
		for _, num := range m.AddressN {
			dAtA[i] = 0x10
			i++
			i = encodeVarintMessages(dAtA, i, uint64(num))
		}
	}
	if m.Coins == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("coins")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Coins))
	}
	if m.Hours == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("hours")
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(*m.Hours))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Initialize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = len(m.State)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetFeatures) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Features) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vendor != nil {
		l = len(*m.Vendor)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.MajorVersion != nil {
		n += 1 + sovMessages(uint64(*m.MajorVersion))
	}
	if m.MinorVersion != nil {
		n += 1 + sovMessages(uint64(*m.MinorVersion))
	}
	if m.PatchVersion != nil {
		n += 1 + sovMessages(uint64(*m.PatchVersion))
	}
	if m.BootloaderMode != nil {
		n += 2
	}
	if m.DeviceId != nil {
		l = len(*m.DeviceId)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.PinProtection != nil {
		n += 2
	}
	if m.PassphraseProtection != nil {
		n += 2
	}
	if m.Language != nil {
		l = len(*m.Language)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Label != nil {
		l = len(*m.Label)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Initialized != nil {
		n += 2
	}
	if m.BootloaderHash != nil {
		l = len(m.BootloaderHash)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.PinCached != nil {
		n += 3
	}
	if m.PassphraseCached != nil {
		n += 3
	}
	if m.FirmwarePresent != nil {
		n += 3
	}
	if m.NeedsBackup != nil {
		n += 3
	}
	if m.Model != nil {
		l = len(*m.Model)
		n += 2 + l + sovMessages(uint64(l))
	}
	if m.FwMajor != nil {
		n += 2 + sovMessages(uint64(*m.FwMajor))
	}
	if m.FwMinor != nil {
		n += 2 + sovMessages(uint64(*m.FwMinor))
	}
	if m.FwPatch != nil {
		n += 2 + sovMessages(uint64(*m.FwPatch))
	}
	if m.FwVersionHead != nil {
		l = len(*m.FwVersionHead)
		n += 2 + l + sovMessages(uint64(l))
	}
	if m.FwVendor != nil {
		l = len(*m.FwVendor)
		n += 2 + l + sovMessages(uint64(l))
	}
	if m.FwVendorKeys != nil {
		l = len(m.FwVendorKeys)
		n += 2 + l + sovMessages(uint64(l))
	}
	if m.UnfinishedBackup != nil {
		n += 3
	}
	if m.FirmwareFeatures != nil {
		n += 2 + sovMessages(uint64(*m.FirmwareFeatures))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ApplySettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Language != nil {
		l = len(*m.Language)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Label != nil {
		l = len(*m.Label)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.UsePassphrase != nil {
		n += 2
	}
	if m.Homescreen != nil {
		l = len(m.Homescreen)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateMnemonic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PassphraseProtection != nil {
		n += 2
	}
	if m.WordCount != nil {
		n += 1 + sovMessages(uint64(*m.WordCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetMnemonic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mnemonic != nil {
		l = len(*m.Mnemonic)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangePin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Remove != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SkycoinAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddressN != nil {
		n += 1 + sovMessages(uint64(*m.AddressN))
	}
	if m.StartIndex != nil {
		n += 1 + sovMessages(uint64(*m.StartIndex))
	}
	if m.ConfirmAddress != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseSkycoinAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseTransactionSign) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for _, s := range m.Signatures {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.Padding != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SkycoinCheckMessageSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = len(*m.Address)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Signature != nil {
		l = len(*m.Signature)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SkycoinSignMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddressN != nil {
		n += 1 + sovMessages(uint64(*m.AddressN))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseSkycoinSignMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignedMessage != nil {
		l = len(*m.SignedMessage)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.ButtonProtection != nil {
		n += 2
	}
	if m.PinProtection != nil {
		n += 2
	}
	if m.PassphraseProtection != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Success) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgType != nil {
		n += 1 + sovMessages(uint64(*m.MsgType))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Failure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgType != nil {
		n += 1 + sovMessages(uint64(*m.MsgType))
	}
	if m.Code != nil {
		n += 1 + sovMessages(uint64(*m.Code))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ButtonRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		n += 1 + sovMessages(uint64(*m.Code))
	}
	if m.Data != nil {
		l = len(*m.Data)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ButtonAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PinMatrixRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMessages(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PinMatrixAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pin != nil {
		l = len(*m.Pin)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PassphraseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OnDevice != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PassphraseAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Passphrase != nil {
		l = len(*m.Passphrase)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.State != nil {
		l = len(m.State)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PassphraseStateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = len(m.State)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PassphraseStateAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRawEntropy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != nil {
		n += 1 + sovMessages(uint64(*m.Size_))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMixedEntropy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != nil {
		n += 1 + sovMessages(uint64(*m.Size_))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Entropy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entropy != nil {
		l = len(m.Entropy)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WipeDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mnemonic != nil {
		l = len(*m.Mnemonic)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Pin != nil {
		l = len(*m.Pin)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.PassphraseProtection != nil {
		n += 2
	}
	if m.Language != nil {
		l = len(*m.Language)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Label != nil {
		l = len(*m.Label)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.SkipChecksum != nil {
		n += 2
	}
	if m.U2FCounter != nil {
		n += 1 + sovMessages(uint64(*m.U2FCounter))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisplayRandom != nil {
		n += 2
	}
	if m.Strength != nil {
		n += 1 + sovMessages(uint64(*m.Strength))
	}
	if m.PassphraseProtection != nil {
		n += 2
	}
	if m.PinProtection != nil {
		n += 2
	}
	if m.Language != nil {
		l = len(*m.Language)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Label != nil {
		l = len(*m.Label)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.U2FCounter != nil {
		n += 1 + sovMessages(uint64(*m.U2FCounter))
	}
	if m.SkipBackup != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntropyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntropyAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entropy != nil {
		l = len(m.Entropy)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecoveryDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WordCount != nil {
		n += 1 + sovMessages(uint64(*m.WordCount))
	}
	if m.PassphraseProtection != nil {
		n += 2
	}
	if m.PinProtection != nil {
		n += 2
	}
	if m.Language != nil {
		l = len(*m.Language)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Label != nil {
		l = len(*m.Label)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.DryRun != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WordRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMessages(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WordAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Word != nil {
		l = len(*m.Word)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirmwareErase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Length != nil {
		n += 1 + sovMessages(uint64(*m.Length))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirmwareRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Offset != nil {
		n += 1 + sovMessages(uint64(*m.Offset))
	}
	if m.Length != nil {
		n += 1 + sovMessages(uint64(*m.Length))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirmwareUpload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = len(m.Payload)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Hash != nil {
		l = len(m.Hash)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionSign) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NbIn != nil {
		n += 1 + sovMessages(uint64(*m.NbIn))
	}
	if len(m.TransactionIn) > 0 {
		for _, e := range m.TransactionIn {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.NbOut != nil {
		n += 1 + sovMessages(uint64(*m.NbOut))
	}
	if len(m.TransactionOut) > 0 {
		for _, e := range m.TransactionOut {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutputsCount != nil {
		n += 1 + sovMessages(uint64(*m.OutputsCount))
	}
	if m.InputsCount != nil {
		n += 1 + sovMessages(uint64(*m.InputsCount))
	}
	if m.CoinName != nil {
		l = len(*m.CoinName)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Version != nil {
		n += 1 + sovMessages(uint64(*m.Version))
	}
	if m.LockTime != nil {
		n += 1 + sovMessages(uint64(*m.LockTime))
	}
	if m.TxHash != nil {
		l = len(*m.TxHash)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestType != nil {
		n += 1 + sovMessages(uint64(*m.RequestType))
	}
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.SignResult) > 0 {
		for _, e := range m.SignResult {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxRequest_TxRequestDetailsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestIndex != nil {
		n += 1 + sovMessages(uint64(*m.RequestIndex))
	}
	if m.TxHash != nil {
		l = len(*m.TxHash)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxRequest_TxRequestSignResponseType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignatureIndex != nil {
		n += 1 + sovMessages(uint64(*m.SignatureIndex))
	}
	if m.Signature != nil {
		l = len(*m.Signature)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxAck_TransactionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		n += 1 + sovMessages(uint64(*m.Version))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.LockTime != nil {
		n += 1 + sovMessages(uint64(*m.LockTime))
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.InputsCnt != nil {
		n += 1 + sovMessages(uint64(*m.InputsCnt))
	}
	if m.OutputsCnt != nil {
		n += 1 + sovMessages(uint64(*m.OutputsCnt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxAck_TransactionType_TxInputType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AddressN) > 0 {
		for _, e := range m.AddressN {
			n += 1 + sovMessages(uint64(e))
		}
	}
	if m.HashIn != nil {
		l = len(*m.HashIn)
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxAck_TransactionType_TxOutputType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = len(*m.Address)
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.AddressN) > 0 {
		for _, e := range m.AddressN {
			n += 1 + sovMessages(uint64(e))
		}
	}
	if m.Coins != nil {
		n += 1 + sovMessages(uint64(*m.Coins))
	}
	if m.Hours != nil {
		n += 1 + sovMessages(uint64(*m.Hours))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMessages(x uint64) (n int) {
	return sovMessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Initialize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Initialize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Initialize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFeatures) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFeatures: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFeatures: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Features) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Features: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Features: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Vendor = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MajorVersion", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MajorVersion = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinorVersion", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinorVersion = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatchVersion", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PatchVersion = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BootloaderMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BootloaderMode = &b
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DeviceId = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PinProtection = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassphraseProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PassphraseProtection = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Language = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Label = &s
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initialized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Initialized = &b
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BootloaderHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BootloaderHash = append(m.BootloaderHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BootloaderHash == nil {
				m.BootloaderHash = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinCached", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PinCached = &b
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassphraseCached", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PassphraseCached = &b
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwarePresent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FirmwarePresent = &b
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedsBackup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NeedsBackup = &b
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Model = &s
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwMajor", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FwMajor = &v
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwMinor", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FwMinor = &v
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwPatch", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FwPatch = &v
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwVersionHead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FwVersionHead = &s
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwVendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FwVendor = &s
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwVendorKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FwVendorKeys = append(m.FwVendorKeys[:0], dAtA[iNdEx:postIndex]...)
			if m.FwVendorKeys == nil {
				m.FwVendorKeys = []byte{}
			}
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnfinishedBackup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UnfinishedBackup = &b
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwareFeatures", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FirmwareFeatures = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplySettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplySettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplySettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Language = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Label = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePassphrase", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UsePassphrase = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homescreen", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homescreen = append(m.Homescreen[:0], dAtA[iNdEx:postIndex]...)
			if m.Homescreen == nil {
				m.Homescreen = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateMnemonic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateMnemonic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateMnemonic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassphraseProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PassphraseProtection = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WordCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WordCount = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetMnemonic) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetMnemonic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetMnemonic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mnemonic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Mnemonic = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("mnemonic")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Remove = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkycoinAddress) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkycoinAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkycoinAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressN", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddressN = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIndex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartIndex = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmAddress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ConfirmAddress = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("address_n")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseSkycoinAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseSkycoinAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseSkycoinAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseTransactionSign) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseTransactionSign: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseTransactionSign: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Padding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Padding = &b
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("padding")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkycoinCheckMessageSignature) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkycoinCheckMessageSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkycoinCheckMessageSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Address = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Signature = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("address")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("message")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("signature")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkycoinSignMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkycoinSignMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkycoinSignMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressN", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddressN = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("address_n")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("message")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseSkycoinSignMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseSkycoinSignMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseSkycoinSignMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SignedMessage = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("signed_message")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ButtonProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ButtonProtection = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PinProtection = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassphraseProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PassphraseProtection = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Success) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Success: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Success: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			var v MessageType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (MessageType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MsgType = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Failure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Failure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Failure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			var v MessageType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (MessageType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MsgType = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v FailureType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (FailureType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ButtonRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ButtonRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ButtonRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v ButtonRequestType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ButtonRequestType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Data = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ButtonAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ButtonAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ButtonAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PinMatrixRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PinMatrixRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PinMatrixRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v PinMatrixRequestType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (PinMatrixRequestType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PinMatrixAck) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PinMatrixAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PinMatrixAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Pin = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("pin")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cancel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cancel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cancel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassphraseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassphraseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassphraseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDevice", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OnDevice = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassphraseAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassphraseAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassphraseAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passphrase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Passphrase = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassphraseStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassphraseStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassphraseStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassphraseStateAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassphraseStateAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassphraseStateAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRawEntropy) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRawEntropy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRawEntropy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Size_ = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("size")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMixedEntropy) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMixedEntropy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMixedEntropy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Size_ = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("size")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entropy) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entropy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entropy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entropy", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entropy = append(m.Entropy[:0], dAtA[iNdEx:postIndex]...)
			if m.Entropy == nil {
				m.Entropy = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("entropy")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WipeDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WipeDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WipeDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mnemonic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Mnemonic = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &HDNodeType{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Pin = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassphraseProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PassphraseProtection = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Language = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Label = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipChecksum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SkipChecksum = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U2FCounter", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.U2FCounter = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayRandom", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DisplayRandom = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Strength = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassphraseProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PassphraseProtection = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PinProtection = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Language = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Label = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U2FCounter", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.U2FCounter = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipBackup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SkipBackup = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntropyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntropyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntropyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntropyAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntropyAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntropyAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entropy", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entropy = append(m.Entropy[:0], dAtA[iNdEx:postIndex]...)
			if m.Entropy == nil {
				m.Entropy = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WordCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WordCount = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassphraseProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PassphraseProtection = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinProtection", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PinProtection = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Language = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Label = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DryRun = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WordRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WordRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WordRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v WordRequestType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (WordRequestType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WordAck) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WordAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WordAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Word", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Word = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("word")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirmwareErase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirmwareErase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirmwareErase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Length = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirmwareRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirmwareRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirmwareRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Offset = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Length = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirmwareUpload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirmwareUpload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirmwareUpload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionSign) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionSign: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionSign: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbIn", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NbIn = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionIn = append(m.TransactionIn, &SkycoinTransactionInput{})
			if err := m.TransactionIn[len(m.TransactionIn)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbOut", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NbOut = &v
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionOut = append(m.TransactionOut, &SkycoinTransactionOutput{})
			if err := m.TransactionOut[len(m.TransactionOut)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("nbIn")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("nbOut")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignTx) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputsCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputsCount = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputsCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputsCount = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CoinName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTime", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LockTime = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TxHash = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("outputs_count")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("inputs_count")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestType", wireType)
			}
			var v TxRequest_RequestType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TxRequest_RequestType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestType = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &TxRequest_TxRequestDetailsType{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignResult = append(m.SignResult, &TxRequest_TxRequestSignResponseType{})
			if err := m.SignResult[len(m.SignResult)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("request_type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRequest_TxRequestDetailsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRequestDetailsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRequestDetailsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestIndex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestIndex = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TxHash = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRequest_TxRequestSignResponseType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRequestSignResponseType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRequestSignResponseType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureIndex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SignatureIndex = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Signature = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &TxAck_TransactionType{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxAck_TransactionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &TxAck_TransactionType_TxInputType{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTime", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LockTime = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, &TxAck_TransactionType_TxOutputType{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputsCnt", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputsCnt = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputsCnt", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputsCnt = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxAck_TransactionType_TxInputType) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxInputType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxInputType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AddressN = append(m.AddressN, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AddressN) == 0 {
					m.AddressN = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AddressN = append(m.AddressN, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressN", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HashIn = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("hashIn")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxAck_TransactionType_TxOutputType) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxOutputType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxOutputType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Address = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AddressN = append(m.AddressN, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AddressN) == 0 {
					m.AddressN = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AddressN = append(m.AddressN, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressN", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Coins = &v
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hours", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hours = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("address")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("coins")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("hours")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessages   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("messages.proto", fileDescriptor_messages_dc51b2d2f6000af7) }

var fileDescriptor_messages_dc51b2d2f6000af7 = []byte{
	// 2599 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x59, 0x4b, 0x73, 0xdb, 0xc8,
	0x11, 0x5e, 0x90, 0x14, 0x1f, 0xcd, 0x87, 0x46, 0x58, 0x59, 0x86, 0x28, 0x4b, 0xd6, 0x42, 0x96,
	0x2c, 0xef, 0x83, 0xd9, 0x68, 0x2b, 0x9b, 0x5a, 0x55, 0xad, 0xab, 0x68, 0x59, 0xb6, 0x55, 0x5e,
	0xc9, 0x2a, 0x88, 0xce, 0x2a, 0x27, 0x16, 0x44, 0x0c, 0x49, 0x44, 0xe4, 0x80, 0x06, 0x06, 0x92,
	0xe8, 0xbc, 0x93, 0x4b, 0x8e, 0xc9, 0x2d, 0x7f, 0x21, 0x97, 0x54, 0x2e, 0xa9, 0x4a, 0xe5, 0x90,
	0xf3, 0x1e, 0x73, 0xcd, 0x29, 0x29, 0x5f, 0x93, 0x73, 0xce, 0xa9, 0x79, 0x00, 0x1c, 0xc0, 0x90,
	0x36, 0x9b, 0x9c, 0x38, 0xdd, 0xfd, 0x4d, 0xf7, 0x74, 0x4f, 0xf7, 0x4c, 0x0f, 0x08, 0x8d, 0x31,
	0x0e, 0x02, 0x7b, 0x80, 0x83, 0xd6, 0xc4, 0xf7, 0xa8, 0xd7, 0xac, 0xd2, 0xe9, 0x24, 0x22, 0x4c,
	0x13, 0xe0, 0x80, 0xb8, 0xd4, 0xb5, 0x47, 0xee, 0x6b, 0xac, 0x2f, 0xc2, 0x5c, 0x40, 0x6d, 0x8a,
	0x0d, 0x6d, 0x5d, 0xdb, 0xae, 0x59, 0x82, 0x30, 0xeb, 0x50, 0x7d, 0x8a, 0xe9, 0x13, 0x6c, 0xd3,
	0xd0, 0xc7, 0x81, 0xf9, 0xef, 0x22, 0x94, 0x23, 0x42, 0x5f, 0x82, 0xe2, 0x05, 0x26, 0x8e, 0xe7,
	0xf3, 0x29, 0x15, 0x4b, 0x52, 0xfa, 0x06, 0xd4, 0xc7, 0xf6, 0x0f, 0x3c, 0xbf, 0x7b, 0x81, 0xfd,
	0xc0, 0xf5, 0x88, 0x91, 0x5b, 0xd7, 0xb6, 0xeb, 0x56, 0x8d, 0x33, 0xbf, 0x27, 0x78, 0x1c, 0xe4,
	0x12, 0x05, 0x94, 0x97, 0x20, 0xc6, 0x54, 0x40, 0x13, 0x9b, 0xf6, 0x86, 0x31, 0xa8, 0x20, 0x40,
	0x9c, 0x19, 0x81, 0xee, 0xc3, 0xfc, 0x99, 0xe7, 0xd1, 0x91, 0x67, 0x3b, 0xd8, 0xef, 0x8e, 0x3d,
	0x07, 0x1b, 0x73, 0xeb, 0xda, 0x76, 0xd9, 0x6a, 0xcc, 0xd8, 0x87, 0x9e, 0x83, 0xf5, 0x15, 0xa8,
	0x38, 0xf8, 0xc2, 0xed, 0xe1, 0xae, 0xeb, 0x18, 0x45, 0xbe, 0xe4, 0xb2, 0x60, 0x1c, 0x38, 0xfa,
	0x26, 0x34, 0x26, 0x2e, 0xe9, 0xb2, 0xc8, 0xe0, 0x1e, 0x65, 0xb6, 0x4a, 0x5c, 0x49, 0x7d, 0xe2,
	0x92, 0xe3, 0x98, 0xa9, 0x7f, 0x02, 0xb7, 0x26, 0x76, 0x10, 0x4c, 0x86, 0xbe, 0x1d, 0x60, 0x15,
	0x5d, 0xe6, 0xe8, 0xc5, 0x99, 0x50, 0x99, 0xd4, 0x84, 0xf2, 0xc8, 0x26, 0x83, 0xd0, 0x1e, 0x60,
	0xa3, 0x22, 0xec, 0x46, 0x34, 0x0b, 0xfb, 0xc8, 0x3e, 0xc3, 0x23, 0x03, 0xb8, 0x40, 0x10, 0xfa,
	0x3a, 0x54, 0xdd, 0x78, 0x6b, 0x1c, 0xa3, 0xc6, 0x95, 0xab, 0xac, 0x94, 0xd7, 0x43, 0x3b, 0x18,
	0x1a, 0x0d, 0xbe, 0x71, 0x8a, 0xd7, 0xcf, 0xec, 0x60, 0xa8, 0xaf, 0x02, 0x30, 0xc7, 0x7a, 0x76,
	0x6f, 0x88, 0x1d, 0x03, 0x71, 0x4d, 0x95, 0x89, 0x4b, 0xf6, 0x38, 0x43, 0xff, 0x00, 0x16, 0x14,
	0x87, 0x24, 0x6a, 0x81, 0xa3, 0xd0, 0x4c, 0x20, 0xc1, 0x0f, 0x00, 0xf5, 0x5d, 0x7f, 0x7c, 0x69,
	0xfb, 0xcc, 0x77, 0x1c, 0x60, 0x42, 0x0d, 0x9d, 0x63, 0xe7, 0x23, 0xfe, 0xb1, 0x60, 0xeb, 0xef,
	0x41, 0x8d, 0x60, 0xec, 0x04, 0xdd, 0x33, 0xbb, 0x77, 0x1e, 0x4e, 0x8c, 0x77, 0x85, 0x0b, 0x9c,
	0xf7, 0x88, 0xb3, 0x98, 0xeb, 0x6c, 0xb7, 0x46, 0xc6, 0x2d, 0xe1, 0x3a, 0x27, 0xf4, 0x65, 0x28,
	0xf7, 0x2f, 0xbb, 0x3c, 0x57, 0x8c, 0x25, 0xbe, 0xdd, 0xa5, 0xfe, 0xe5, 0x21, 0x23, 0x23, 0x11,
	0xcb, 0x10, 0xe3, 0x76, 0x2c, 0x62, 0xa4, 0x14, 0xf1, 0xbc, 0x30, 0x8c, 0x48, 0x74, 0xcc, 0x48,
	0x7d, 0x0b, 0xe6, 0xfb, 0x97, 0x51, 0x06, 0x75, 0x87, 0xd8, 0x76, 0x8c, 0x65, 0x6e, 0xb0, 0xde,
	0xbf, 0x94, 0x39, 0xf4, 0x0c, 0xdb, 0x0e, 0x4b, 0x0f, 0x8e, 0xe3, 0x19, 0xdd, 0x14, 0xdb, 0xc4,
	0x10, 0x3c, 0xa7, 0xef, 0x41, 0x23, 0x16, 0x76, 0xcf, 0xf1, 0x34, 0x30, 0x56, 0x78, 0xb4, 0x6b,
	0x11, 0xe2, 0x39, 0x9e, 0x06, 0x2c, 0x98, 0x21, 0xe9, 0xbb, 0xc4, 0x0d, 0x86, 0xd8, 0x89, 0x3c,
	0xbf, 0x23, 0x82, 0x39, 0x13, 0x48, 0xf7, 0x3f, 0x80, 0x85, 0x38, 0x98, 0x7d, 0x59, 0x53, 0xc6,
	0x2a, 0x5f, 0x7b, 0x1c, 0xe5, 0xb8, 0xf0, 0x7e, 0xa5, 0x41, 0xbd, 0x3d, 0x99, 0x8c, 0xa6, 0x27,
	0x98, 0x52, 0x97, 0x0c, 0x82, 0x44, 0x52, 0x69, 0xd7, 0x25, 0x55, 0x4e, 0x4d, 0xaa, 0x4d, 0x68,
	0x84, 0x2c, 0x69, 0xe3, 0x5d, 0xe5, 0x35, 0x57, 0xb6, 0xea, 0x61, 0x80, 0x8f, 0x63, 0xa6, 0xbe,
	0x06, 0x30, 0xf4, 0xc6, 0x38, 0xe8, 0xf9, 0x18, 0x8b, 0x8a, 0xab, 0x59, 0x0a, 0xc7, 0xec, 0x03,
	0x7a, 0x8a, 0x09, 0xf6, 0x6d, 0x8a, 0x0f, 0x09, 0x1e, 0x7b, 0xc4, 0xed, 0x5d, 0x5f, 0x16, 0xda,
	0x0d, 0x65, 0xb1, 0x0a, 0x70, 0xe9, 0xf9, 0x4e, 0xb7, 0xe7, 0x85, 0x84, 0xca, 0x43, 0xa2, 0xc2,
	0x38, 0x7b, 0x8c, 0x61, 0x3e, 0x80, 0xea, 0x09, 0xa6, 0xb1, 0x89, 0x26, 0x94, 0xc7, 0x72, 0x6c,
	0x68, 0xeb, 0x39, 0xe6, 0x6f, 0x44, 0x9b, 0x1b, 0x50, 0xd9, 0x1b, 0xda, 0x64, 0x80, 0x8f, 0x5d,
	0xc2, 0x8e, 0x25, 0x1f, 0x8f, 0xbd, 0x0b, 0x2c, 0x8d, 0x4b, 0xca, 0xbc, 0x84, 0xc6, 0xc9, 0xf9,
	0xb4, 0xe7, 0xb9, 0xa4, 0xed, 0x38, 0x3e, 0x0e, 0x02, 0xb6, 0xe3, 0xb6, 0x18, 0x76, 0x09, 0xd7,
	0x59, 0xb7, 0xca, 0x92, 0x71, 0xa4, 0xdf, 0x85, 0x6a, 0x40, 0x6d, 0x9f, 0x76, 0x5d, 0xe2, 0xe0,
	0x2b, 0xb9, 0x3c, 0xe0, 0xac, 0x03, 0xc6, 0x61, 0x15, 0xd8, 0xf3, 0x08, 0xdb, 0xa9, 0xae, 0x9c,
	0x24, 0xe3, 0xd9, 0x90, 0x6c, 0x69, 0xc6, 0xfc, 0x14, 0x96, 0x2c, 0x1c, 0x4c, 0x3c, 0x12, 0xe0,
	0xd4, 0x02, 0xee, 0xc4, 0x0b, 0xc0, 0x81, 0xa1, 0xad, 0xe7, 0xb7, 0x2b, 0xd6, 0x8c, 0x61, 0x9e,
	0xc0, 0xed, 0x68, 0x5e, 0xc7, 0xb7, 0x49, 0x60, 0xf3, 0xb0, 0x9d, 0xb8, 0x03, 0xc2, 0xf6, 0x28,
	0x70, 0x07, 0x44, 0x26, 0x8d, 0x98, 0xa9, 0x70, 0x74, 0x03, 0x4a, 0x13, 0xdb, 0x71, 0x5c, 0x32,
	0x30, 0x72, 0xeb, 0xb9, 0xed, 0xb2, 0x15, 0x91, 0xe6, 0x04, 0xee, 0xc8, 0x45, 0xec, 0x0d, 0x71,
	0xef, 0xfc, 0x50, 0xdc, 0x0f, 0x27, 0xd1, 0x54, 0x36, 0x33, 0xf2, 0x46, 0x44, 0x39, 0x22, 0x99,
	0x44, 0xde, 0x26, 0x5c, 0x67, 0xc5, 0x8a, 0x48, 0xe6, 0x46, 0x6c, 0xdb, 0xc8, 0x73, 0xd9, 0x8c,
	0x61, 0x3e, 0x07, 0x5d, 0x5a, 0x64, 0x56, 0xa4, 0xc1, 0x9b, 0x63, 0x7f, 0xad, 0x29, 0x73, 0x0f,
	0x9a, 0xa9, 0x58, 0xaa, 0x4a, 0x37, 0xa1, 0xc1, 0xec, 0x62, 0xa7, 0x1b, 0x4d, 0x17, 0x3e, 0xd4,
	0x05, 0x57, 0xc2, 0xcc, 0xdf, 0x69, 0x50, 0x38, 0x76, 0xc9, 0x40, 0xb5, 0x23, 0x4a, 0x28, 0x76,
	0xe9, 0x03, 0x58, 0x38, 0x0b, 0x29, 0xf5, 0x12, 0x37, 0x42, 0x4e, 0x54, 0xb2, 0x10, 0x28, 0x89,
	0xfc, 0xf6, 0xdd, 0x91, 0xff, 0x46, 0x77, 0x47, 0xe1, 0xfa, 0x22, 0x31, 0xbf, 0x80, 0xd2, 0x49,
	0xd8, 0xeb, 0xb1, 0x0d, 0xb8, 0x0f, 0xe5, 0x71, 0x30, 0xe8, 0xb2, 0x2b, 0x9c, 0x2f, 0xb7, 0xb1,
	0x53, 0x6b, 0x49, 0x97, 0x3a, 0xd3, 0x09, 0xb6, 0x4a, 0xe3, 0x60, 0xc0, 0x06, 0xc9, 0xf0, 0xa9,
	0x6e, 0x99, 0x04, 0x4a, 0x4f, 0x6c, 0x77, 0xc4, 0x36, 0xfa, 0xbf, 0xd6, 0xb6, 0x0e, 0x85, 0x1e,
	0xbb, 0x54, 0x73, 0x12, 0x24, 0x15, 0x70, 0x10, 0x97, 0xa8, 0xf6, 0xf2, 0x49, 0x7b, 0xcf, 0xa1,
	0xfe, 0x88, 0x47, 0xcb, 0xc2, 0xaf, 0x42, 0x1c, 0x50, 0x7d, 0x4b, 0x2a, 0x13, 0x16, 0xf5, 0x56,
	0x42, 0xaa, 0xa8, 0xd4, 0xa1, 0xe0, 0xd8, 0xd4, 0x96, 0xeb, 0xe7, 0x63, 0xb3, 0x0a, 0x15, 0x01,
	0x6f, 0xf7, 0xce, 0xcd, 0xcf, 0x01, 0x1d, 0xbb, 0xe4, 0xd0, 0xa6, 0xbe, 0x7b, 0x15, 0x29, 0x7f,
	0x00, 0x05, 0xc5, 0x9d, 0x5b, 0xad, 0x34, 0x40, 0xe8, 0x67, 0x10, 0x73, 0x1d, 0x6a, 0xb1, 0xb4,
	0xdd, 0x3b, 0xd7, 0x11, 0xe4, 0x27, 0x2e, 0x91, 0xe9, 0xc2, 0x86, 0x66, 0x19, 0x8a, 0x7b, 0x36,
	0xe9, 0xe1, 0x91, 0xf9, 0x31, 0x2c, 0xcc, 0x8e, 0xc7, 0xc8, 0xd6, 0x0a, 0x54, 0x3c, 0xd2, 0x15,
	0xed, 0x83, 0x3c, 0x68, 0xca, 0x1e, 0x79, 0xcc, 0x69, 0x73, 0x1f, 0xea, 0xb3, 0x19, 0x4c, 0xfd,
	0x1a, 0x80, 0x72, 0xec, 0x8a, 0x5c, 0x53, 0x38, 0xb3, 0xe6, 0x2b, 0xa7, 0x36, 0x5f, 0x2d, 0x58,
	0x9a, 0xa9, 0x39, 0x61, 0xac, 0xc8, 0x7a, 0x76, 0xb3, 0xb6, 0x08, 0x7a, 0x0a, 0xcf, 0x22, 0xb5,
	0x01, 0xf5, 0xa7, 0x98, 0x5a, 0xf6, 0xe5, 0x3e, 0xa1, 0xbe, 0x37, 0x99, 0xb2, 0xd8, 0x06, 0xee,
	0x6b, 0x2c, 0xab, 0x8e, 0x8f, 0xcd, 0x4d, 0x98, 0x7f, 0x8a, 0xe9, 0xa1, 0x7b, 0x85, 0x9d, 0x9b,
	0x60, 0x1b, 0x50, 0x8a, 0xc4, 0x06, 0x94, 0xb0, 0x18, 0x72, 0x44, 0xcd, 0x8a, 0x48, 0xb3, 0x06,
	0xf0, 0xa5, 0x3b, 0xc1, 0x32, 0x16, 0xbf, 0xc9, 0x01, 0x7c, 0xe1, 0xd9, 0x8e, 0x20, 0x53, 0xc7,
	0xb8, 0xa6, 0x1e, 0xe3, 0xfa, 0x5d, 0x28, 0x90, 0x28, 0xd3, 0xaa, 0x3b, 0xd5, 0xd6, 0xb3, 0xc7,
	0x47, 0x9e, 0x23, 0x13, 0x8d, 0x09, 0xa2, 0x5d, 0x12, 0x49, 0xc6, 0x86, 0xff, 0x53, 0x4d, 0xe9,
	0x1b, 0xca, 0xd5, 0xc9, 0x5a, 0xc5, 0xca, 0x6e, 0x09, 0x93, 0xc1, 0xc8, 0x0d, 0x86, 0x59, 0x77,
	0x68, 0x51, 0xbd, 0x43, 0x37, 0xa0, 0x1e, 0x9c, 0xbb, 0x93, 0x6e, 0x8f, 0x1d, 0x9e, 0x41, 0x38,
	0x96, 0x5d, 0x62, 0x8d, 0x31, 0xf7, 0x24, 0x8f, 0x5d, 0x1d, 0xe1, 0x4e, 0x5f, 0xdc, 0x6b, 0xd8,
	0xe7, 0xad, 0x61, 0xdd, 0x82, 0x70, 0xa7, 0xbf, 0x27, 0x38, 0xe6, 0xef, 0x73, 0x50, 0xb5, 0x70,
	0x80, 0xa9, 0x0c, 0xca, 0x26, 0x34, 0x1c, 0x37, 0x98, 0x8c, 0xec, 0x69, 0xd7, 0xb7, 0x89, 0xe3,
	0x8d, 0x65, 0x46, 0xd5, 0x25, 0xd7, 0xe2, 0x4c, 0xfd, 0x2e, 0x94, 0x03, 0xea, 0x63, 0x32, 0xa0,
	0x43, 0x71, 0x1f, 0xed, 0xe6, 0x77, 0xbe, 0xf3, 0xa9, 0x15, 0x33, 0xaf, 0x8f, 0x46, 0xfe, 0x86,
	0x68, 0xbc, 0x7d, 0x7a, 0x15, 0xb2, 0x4e, 0xaf, 0xff, 0x23, 0x68, 0xa9, 0x78, 0x94, 0xd2, 0xf1,
	0xe0, 0x77, 0x2d, 0x8b, 0xaa, 0xec, 0x98, 0x44, 0x2f, 0x0d, 0x8c, 0x25, 0x7a, 0x25, 0xb3, 0x01,
	0x35, 0x31, 0x92, 0x49, 0x85, 0xa0, 0x21, 0xf3, 0x50, 0x56, 0x84, 0xb9, 0x05, 0x20, 0x39, 0xac,
	0xde, 0x12, 0xc9, 0xa9, 0xa9, 0xc9, 0xf9, 0x77, 0x0d, 0x1a, 0x16, 0xee, 0x79, 0x17, 0xd8, 0x9f,
	0xca, 0xe8, 0x27, 0xfb, 0x10, 0x2d, 0xd5, 0x87, 0x5c, 0x1f, 0xd4, 0xdc, 0x37, 0x0a, 0x6a, 0xfe,
	0xeb, 0x82, 0x5a, 0xf8, 0xda, 0xa0, 0xce, 0xa9, 0x41, 0xbd, 0x0d, 0x25, 0xc7, 0x9f, 0x76, 0xfd,
	0x90, 0xf0, 0x60, 0x97, 0xad, 0xa2, 0xe3, 0x4f, 0xad, 0x90, 0x98, 0x9f, 0x40, 0xf5, 0x4b, 0xcf,
	0x77, 0xa2, 0xa3, 0xe2, 0x5e, 0xe2, 0x50, 0x44, 0x2d, 0x45, 0xa6, 0x9c, 0x87, 0xab, 0x50, 0x62,
	0x02, 0x16, 0x3b, 0x1d, 0x0a, 0xcc, 0x79, 0x79, 0x16, 0xf2, 0xb1, 0x79, 0x1f, 0xea, 0x4f, 0x64,
	0x4b, 0xba, 0xcf, 0x0f, 0xac, 0x25, 0x28, 0x8e, 0x44, 0x22, 0x8a, 0x78, 0x49, 0xca, 0x6c, 0xc3,
	0x7c, 0x04, 0x8c, 0x16, 0xb0, 0x04, 0x45, 0xaf, 0xdf, 0x0f, 0x70, 0x14, 0x5a, 0x49, 0x29, 0x2a,
	0x72, 0x09, 0x15, 0x0f, 0xa1, 0x11, 0xa9, 0x78, 0x39, 0x61, 0x0f, 0x19, 0xd1, 0xcd, 0x4c, 0xd9,
	0x30, 0xda, 0x4d, 0x49, 0xb2, 0xb5, 0xf2, 0xa7, 0x8f, 0x38, 0x36, 0xf9, 0xd8, 0xfc, 0x8b, 0x06,
	0xf3, 0xe9, 0x7e, 0x49, 0x87, 0x02, 0x39, 0x3b, 0x88, 0x1a, 0x0d, 0x3e, 0xd6, 0x1f, 0x42, 0x9d,
	0xce, 0x60, 0x07, 0x6c, 0x3f, 0xf3, 0xdb, 0xd5, 0x1d, 0xa3, 0x25, 0x1b, 0x8b, 0x8e, 0x2a, 0x9c,
	0x84, 0xd4, 0x4a, 0xc2, 0xd9, 0xb6, 0x90, 0xb3, 0x17, 0x21, 0xe5, 0x1d, 0x4f, 0xdd, 0x12, 0x84,
	0xde, 0x86, 0x86, 0x02, 0x63, 0xe2, 0x02, 0x57, 0xbb, 0x9c, 0xa1, 0xf6, 0x45, 0x48, 0x99, 0xde,
	0xd4, 0x04, 0xf3, 0x2b, 0x0d, 0x8a, 0x6c, 0xd5, 0x9d, 0x2b, 0x76, 0xdc, 0x78, 0x1c, 0x14, 0xc4,
	0xd9, 0xc9, 0x6c, 0xd5, 0x24, 0x53, 0x24, 0xe8, 0x7b, 0x50, 0x73, 0x89, 0x82, 0xc9, 0x71, 0x4c,
	0x55, 0xf0, 0x04, 0x64, 0x1d, 0x2a, 0xcc, 0x76, 0x97, 0xd8, 0x63, 0x79, 0x47, 0xef, 0xe6, 0x4f,
	0x9e, 0x7f, 0xdf, 0x2a, 0x33, 0xee, 0x91, 0x3d, 0x66, 0xfd, 0x58, 0x29, 0xf1, 0xc8, 0xde, 0xd5,
	0xbe, 0x6d, 0x45, 0x1c, 0x7d, 0x0d, 0x2a, 0x23, 0xaf, 0x77, 0xde, 0xa5, 0xee, 0x58, 0x14, 0x7f,
	0x7d, 0x57, 0xfb, 0xd8, 0x2a, 0x33, 0x5e, 0xc7, 0x1d, 0x63, 0x96, 0x8b, 0xf4, 0x4a, 0x3c, 0x42,
	0x45, 0xe1, 0x17, 0xe9, 0x15, 0x7b, 0x7c, 0x9a, 0x7f, 0xcb, 0x43, 0xa5, 0x13, 0xdf, 0xcf, 0x9f,
	0x41, 0xcd, 0x17, 0xc3, 0xa8, 0xed, 0xc8, 0x6d, 0x37, 0x76, 0x96, 0x5a, 0x31, 0xa2, 0xa5, 0x26,
	0x66, 0xd5, 0x9f, 0x11, 0xfa, 0x67, 0x50, 0x72, 0x30, 0xb5, 0xdd, 0x51, 0x20, 0x6f, 0x87, 0xbb,
	0xca, 0xac, 0x78, 0xf4, 0x58, 0x40, 0x44, 0xff, 0x22, 0xf1, 0xfa, 0x3e, 0x54, 0x59, 0xfb, 0xd7,
	0xf5, 0x71, 0x10, 0x8e, 0xd8, 0x6e, 0xb1, 0xed, 0xb8, 0x97, 0x35, 0x9d, 0x05, 0x3d, 0xee, 0xb8,
	0x99, 0x0e, 0xde, 0x52, 0x5b, 0x7c, 0x5e, 0xb3, 0x03, 0x8b, 0x59, 0x76, 0xd8, 0x16, 0x45, 0x4e,
	0x89, 0x97, 0x82, 0xc8, 0xf2, 0xc8, 0x53, 0xf1, 0x56, 0x50, 0x02, 0x94, 0x53, 0x03, 0xd4, 0x3c,
	0x83, 0xe5, 0x6b, 0xcd, 0xb3, 0x17, 0x46, 0xdc, 0x46, 0x27, 0x94, 0x37, 0x62, 0xb6, 0x50, 0x9f,
	0x68, 0xc0, 0x85, 0x01, 0xa5, 0x01, 0x7f, 0xc9, 0x2e, 0x9b, 0x59, 0x28, 0xab, 0x50, 0xea, 0x9c,
	0x1e, 0x1c, 0x1d, 0xbf, 0xec, 0xa0, 0x77, 0xf4, 0x1a, 0x94, 0x3b, 0xa7, 0x2f, 0x5e, 0x76, 0x18,
	0xa5, 0xe9, 0x00, 0xc5, 0xce, 0xe9, 0xe1, 0x7e, 0xa7, 0x8d, 0x72, 0x7a, 0x03, 0xa0, 0x73, 0xfa,
	0xe4, 0xe0, 0xe8, 0xe0, 0xe4, 0xd9, 0xfe, 0x63, 0x94, 0xd7, 0xe7, 0xa1, 0xda, 0x39, 0xdd, 0x3f,
	0xed, 0x58, 0xed, 0xc7, 0xed, 0x4e, 0x1b, 0x15, 0xcc, 0x7f, 0xe5, 0x61, 0xae, 0xc3, 0x9b, 0xa7,
	0x2d, 0xc8, 0x51, 0xb1, 0xb4, 0x2a, 0xdf, 0xcd, 0x76, 0xef, 0xbc, 0xa5, 0xa4, 0x39, 0x0f, 0x65,
	0x8e, 0x5e, 0x35, 0xff, 0x9c, 0x4f, 0x54, 0x66, 0xd4, 0xab, 0x46, 0x79, 0x27, 0x7c, 0x8b, 0x93,
	0x6e, 0x17, 0x8a, 0x22, 0x85, 0x65, 0x61, 0x9a, 0xd9, 0x9a, 0x5b, 0x9d, 0x2b, 0x5e, 0x9e, 0xdc,
	0x8a, 0x9c, 0xc1, 0xba, 0xb3, 0x59, 0xc2, 0x8a, 0x8f, 0x46, 0xb3, 0x6c, 0xfd, 0x1c, 0x4a, 0xb2,
	0x7e, 0x8c, 0x39, 0xae, 0x79, 0xe3, 0x5a, 0xcd, 0xa2, 0x42, 0x45, 0x3e, 0xc9, 0x39, 0xec, 0xba,
	0x88, 0xca, 0x8d, 0x50, 0x9e, 0xef, 0x75, 0xab, 0x22, 0x8b, 0x8d, 0x50, 0x76, 0x97, 0xc5, 0x25,
	0x4b, 0x68, 0x74, 0xd9, 0x45, 0x05, 0x4b, 0x68, 0xf3, 0x11, 0x54, 0x95, 0x25, 0xa7, 0x1f, 0x42,
	0xf9, 0xc4, 0x43, 0x68, 0x09, 0x8a, 0x2c, 0x69, 0xf8, 0xe1, 0xc4, 0x4e, 0x63, 0x49, 0x35, 0x5f,
	0x41, 0x4d, 0x5d, 0xdc, 0x0d, 0xaf, 0xb6, 0x84, 0xfa, 0x5c, 0x4a, 0xfd, 0x22, 0xcc, 0xb1, 0x03,
	0x20, 0xe0, 0x47, 0x58, 0xc1, 0x12, 0x04, 0xe3, 0x0e, 0xbd, 0xd0, 0x0f, 0x8c, 0x82, 0xe0, 0x72,
	0xe2, 0xfd, 0x7f, 0xd6, 0xa1, 0xaa, 0xbc, 0x0f, 0xf4, 0x75, 0x58, 0x52, 0xc8, 0xee, 0xec, 0x4b,
	0x22, 0x7a, 0xa7, 0x59, 0xf8, 0xf5, 0x1f, 0x0d, 0x4d, 0x6f, 0x02, 0x52, 0x11, 0xec, 0xc5, 0x85,
	0x34, 0x29, 0x5b, 0x85, 0x77, 0x55, 0x99, 0x7c, 0xe2, 0xa0, 0x5c, 0xb3, 0xf0, 0xdb, 0x0c, 0xb1,
	0x7c, 0x72, 0xa0, 0xbc, 0x14, 0xdf, 0x85, 0x5b, 0xaa, 0x38, 0x7e, 0xfb, 0xa3, 0x82, 0x54, 0x9f,
	0x5a, 0xdc, 0xac, 0x1d, 0x45, 0x73, 0x12, 0x71, 0x1f, 0x96, 0x13, 0x16, 0xd4, 0xdb, 0x0d, 0x15,
	0x9b, 0x65, 0x06, 0xfa, 0x13, 0x03, 0x6e, 0x43, 0x33, 0x0b, 0x28, 0xae, 0x26, 0x54, 0x52, 0x90,
	0x1b, 0x49, 0x95, 0x89, 0xa6, 0x1b, 0x55, 0xb2, 0x1d, 0x8f, 0xc4, 0x20, 0x3d, 0x4b, 0x2d, 0x7c,
	0xd6, 0x38, 0xa3, 0xba, 0x54, 0xf0, 0x1e, 0xdc, 0x56, 0x11, 0x4a, 0x1b, 0x89, 0x1a, 0x12, 0xb2,
	0x06, 0x8b, 0x89, 0x25, 0xcb, 0x8f, 0x48, 0x68, 0x41, 0x1a, 0xd9, 0x82, 0x3b, 0xa9, 0x8d, 0x49,
	0x3c, 0x93, 0x90, 0x1e, 0xe3, 0x8c, 0x4c, 0x5c, 0xbb, 0x77, 0x8e, 0xde, 0x15, 0x8e, 0xff, 0x81,
	0xe1, 0xee, 0x80, 0x9e, 0xd8, 0x0e, 0xfe, 0x6c, 0x42, 0x8b, 0x72, 0x35, 0xa9, 0xb0, 0x24, 0xbe,
	0x62, 0xa1, 0xe5, 0x6c, 0x50, 0xe2, 0x59, 0x88, 0x9a, 0x72, 0x3d, 0x1b, 0xc9, 0x6d, 0x8f, 0x1f,
	0x83, 0x68, 0x45, 0x59, 0x8c, 0x99, 0x5c, 0xb4, 0xda, 0x36, 0x22, 0x53, 0x5a, 0xbb, 0x97, 0xdc,
	0xd3, 0x64, 0x2b, 0x89, 0x36, 0xb2, 0xf7, 0x62, 0xd6, 0x5e, 0xa2, 0x7b, 0x71, 0x12, 0xad, 0x26,
	0x02, 0x94, 0x7e, 0x25, 0xa2, 0x07, 0x52, 0x55, 0x2a, 0xdb, 0x12, 0x8f, 0x43, 0xf4, 0xbe, 0xb2,
	0xfa, 0xd4, 0xca, 0x92, 0x9d, 0x2a, 0xfa, 0x28, 0x3b, 0x07, 0x94, 0x96, 0x0e, 0xb5, 0xb2, 0x2b,
	0x48, 0x36, 0x77, 0xe8, 0x5b, 0xd9, 0x1a, 0x94, 0x6f, 0xfc, 0xe8, 0xbb, 0x12, 0xf2, 0x21, 0x98,
	0xd9, 0x6b, 0x56, 0x5f, 0xa2, 0xe8, 0x50, 0xda, 0xfb, 0x10, 0xd6, 0x6e, 0x40, 0x33, 0xd3, 0x47,
	0x8a, 0x9b, 0x29, 0xf3, 0xca, 0x77, 0x3e, 0xf4, 0x2a, 0x7b, 0x8f, 0x92, 0x5f, 0xce, 0x90, 0x2f,
	0x51, 0x3b, 0xb0, 0x9d, 0x81, 0xca, 0xfc, 0xb4, 0x85, 0x02, 0x39, 0x67, 0x3b, 0xb9, 0xd4, 0xb7,
	0xbf, 0x23, 0x21, 0x9a, 0x1d, 0x82, 0xec, 0xaf, 0x78, 0x28, 0x94, 0x21, 0xf8, 0x18, 0xb6, 0x6e,
	0x40, 0xab, 0xfa, 0x2f, 0xb2, 0x0b, 0x31, 0xfd, 0x59, 0x15, 0x5d, 0xca, 0x75, 0x6c, 0xc2, 0x8a,
	0x8a, 0x4b, 0x75, 0xb7, 0xe8, 0xb5, 0x84, 0x7d, 0x04, 0x1b, 0x59, 0x0b, 0x48, 0xc3, 0x7f, 0x28,
	0xad, 0xa7, 0xb4, 0xa6, 0xde, 0xff, 0xe8, 0x47, 0x52, 0x6b, 0xaa, 0xba, 0x45, 0x67, 0x8a, 0x7e,
	0x2c, 0xa5, 0xa9, 0xa3, 0x38, 0x6e, 0x66, 0xd0, 0x4f, 0xa4, 0x95, 0x15, 0x58, 0x48, 0x02, 0x58,
	0x2e, 0xfc, 0x34, 0x2e, 0xfb, 0x64, 0xb1, 0xba, 0x94, 0xb7, 0xc8, 0x1c, 0xf3, 0x33, 0x2d, 0xf6,
	0xbe, 0x99, 0x01, 0x8a, 0xa2, 0xff, 0xf3, 0x08, 0xb6, 0x95, 0x74, 0x67, 0x9f, 0x0e, 0xb1, 0x8f,
	0xc3, 0xe8, 0x2b, 0x2c, 0xfa, 0x85, 0x96, 0x6d, 0x93, 0xe3, 0xc2, 0xb1, 0xb0, 0xf9, 0x4b, 0x09,
	0x7a, 0xf4, 0xf0, 0xab, 0x37, 0x6b, 0xda, 0x5f, 0xdf, 0xac, 0x69, 0xff, 0x78, 0xb3, 0xa6, 0xc1,
	0x1a, 0xc1, 0xb4, 0x15, 0x88, 0x7d, 0x64, 0xbf, 0x97, 0xf6, 0x68, 0x84, 0xa9, 0xf8, 0x1b, 0xed,
	0x2c, 0xec, 0x3f, 0x42, 0x27, 0x11, 0x4f, 0x6a, 0xfe, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x71,
	0x17, 0xe9, 0x29, 0x79, 0x1b, 0x00, 0x00,
}
